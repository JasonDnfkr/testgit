[TOC]



### HTTP

#### 1. HTTP 是什么

超文本传输协议。



#### 2. HTTP 状态码

`1xx` 类状态码属于**提示信息**，是协议处理中的一种中间状态，实际用到的比较少。

`2xx` 类状态码表示服务器**成功**处理了客户端的请求，也是我们最愿意看到的状态。

- 「**200 OK**」是最常见的成功状态码，表示一切正常。如果是非 `HEAD` 请求，服务器返回的响应头都会有 body 数据。
- 「**204 No Content**」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。
- 「**206 Partial Content**」是应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。

`3xx` 类状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是**重定向**。

- 「**301 Moved Permanently**」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。
- 「**302 Found**」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。

301 和 302 都会在响应头里使用字段 `Location`，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。

- 「**304 Not Modified**」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，也就是告诉客户端可以继续使用缓存资源，用于缓存控制。

`4xx` 类状态码表示客户端发送的**报文有误**，服务器无法处理，也就是错误码的含义。

- 「**400 Bad Request**」表示客户端请求的报文有错误，但只是个笼统的错误。
- 「**403 Forbidden**」表示服务器禁止访问资源，并不是客户端的请求出错。
- 「**404 Not Found**」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。

`5xx` 类状态码表示客户端请求报文正确，但是**服务器处理时内部发生了错误**，属于服务器端的错误码。

- 「**500 Internal Server Error**」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。
- 「**501 Not Implemented**」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。
- 「**502 Bad Gateway**」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。
- 「**503 Service Unavailable**」表示服务器当前很忙，暂时无法响应客户端，类似“网络服务正忙，请稍后重试”的意思。





#### 3. HTTP 常见字段

1. Host：主机名
2. Content-Length：表示HTTP报文的数据长度
3. Connection：最常用于客户端要求服务器使用「HTTP 长连接」机制，以便请求其他复用。`Keep-Alive`是为了兼容老版本HTTP协议，需要手动设置的字段值。
4. Content-Type: 编码格式。text/html; Charset=utf-8
5. Accept：客户端能接受的编码格式
6. Content-Encoding / Accept-Encoding: 压缩方式，比如gzip



#### 4. GET 和 POST

**GET：**GET 的语义是从服务器获取指定的资源。请求的参数一般写在 URL 中。URL 规定只能支持 ASCII，所以 GET 请求的参数只允许 ASCII 字符。GET 一般作为资源的访问，所以通常可以被浏览器缓存。

**POST：**POST 的语义是根据请求负荷（报文body）对指定的资源做出处理。POST 请求携带数据的位置一般是写在报文 body 中，body 中的数据可以是任意格式的数据，只要客户端与服务端协商好即可，而且浏览器不会对 body 大小做限制。POST 请求多要修改服务器中的资源，所以浏览器一般不缓存。



#### 5. 浏览器缓存

**强制缓存：**只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存，决定是否使用缓存的主动性在于浏览器这边。

**协商缓存：**浏览器先访问本地的缓存，然后发一个HTTP请求，头部带上etag，服务器比较请求与本地资源的etag，若一致，则返回304，表示允许使用。



#### 6. HTTP/1.1

HTTP/1.1 采用了长连接的方式，即可在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。

但是**服务器必须按照接收请求的顺序发送对这些管道化请求的响应**。如果服务端在处理 A 请求时耗时比较长，那么后续的请求的处理都会被阻塞住，这称为「队头堵塞」。

#### 7. HTTP/2

1. HTTP/2会**压缩头**（Header）如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你**消除重复的部分**。
2. 二进制格式。不再采用纯文本格式，比如以前的HTTP/1.1，状态码200，以前会储存三个ASCII码，现在直接一个字节就搞定了。
3. 并发传输。不再会存在HTTP/1.1中的队头阻塞问题。
4. 服务端可以主动向客户端发送数据。比如，客户端通过 HTTP/1.1 请求从服务器那获取到了 HTML 文件，而 HTML 可能还需要依赖 CSS 来渲染页面，这时客户端还要再发起获取 CSS 文件的请求。在 HTTP/2 中，客户端在访问 HTML 时，服务器可以直接主动推送 CSS 文件，减少了消息传递的次数。

**HTTP/2存在的缺点，是TCP层面连接固有的。比如丢包，内核不会读走丢包后的缓冲区里面的内容，直到申请重传或接收到了为止。**



#### 8. HTTPS

- HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。

- 两者的默认端口不一样，HTTP 默认端口号是 80，HTTPS 默认端口号是 443。



### 键入网址到网页显示，发生了什么？

1. URL解析

请求的域名，请求的文件等。生成 http 请求报文

2. DNS解析

浏览器缓存，操作系统缓存，本地hosts缓存，访问DNS服务器（根域名服务器(.)、顶级域名服务器(.com)...）

3. 建立TCP连接

4. 请求封装成数据包，发送

5. 服务端接收到数据包，解析http请求，回送http响应报文
6. 客户端解析，浏览器渲染页面
