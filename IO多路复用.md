### IO多路复用

#### 1. 做什么用

是一种网络通信的手段（机制），通过这种方式可以**同时监测多个文件描述符并且这个过程是阻塞的，一旦检测到有文件描述符就绪（可以读数据或者可以写数据）程序的阻塞就会被解除，之后就可以基于这些（一个或多个）就绪的文件描述符进行通信了。**通过这种方式在单线程 / 进程的场景下也可以在服务器端实现并发。



#### 2. 实现原理

使用 IO 多路转接函数，委托内核检测服务器端所有的文件描述符（通信和监听两类），这个检测过程会导致进程 / 线程的阻塞，如果检测到已就绪的文件描述符阻塞解除，并将这些已就绪的文件描述符传出。



#### 3. select

select函数委托内核来查询文件描述符集合中的fd的状态。select函数是阻塞的，如果检测到fd的标志位变为1，则说明该fd指向的文件的缓冲区有变化了，就会解除阻塞。select会返回这些发生了变化的文件描述符。程序可以根据需求，分别遍历这些文件描述符，然后做出相应的处理。



#### 4. poll

poll和select的功能相似，但是select是跨平台的，函数参数调用的方法有一些不一样。对于select，能够检测的最大文件描述符上限是1024，poll没有。



#### 5. epoll

epoll 全称 eventpoll，是 linux 内核实现 IO 多路转接 / 复用（IO multiplexing）的一个实现。epoll 是 select 和 poll 的升级版，改进了工作方式，因此它更加高效。

- 对于待检测集合select和poll是基于线性方式处理的，epoll是基于红黑树来管理待检测集合的。

- select和poll每次都会线性扫描整个待检测集合，集合越大速度越慢，epoll使用的是回调机制，效率高，处理效率也不会随着检测集合的变大而下降
- select和poll工作过程中存在内核/用户空间数据的频繁拷贝问题，在epoll中内核和用户区使用的是共享内存（基于mmap内存映射区实现），省去了不必要的内存拷贝。
- 程序猿需要对select和poll返回的集合进行判断才能知道哪些文件描述符是就绪的，通过epoll可以直接得到已就绪的文件描述符集合，无需再次检测
- 使用 epoll 没有最大文件描述符的限制，仅受系统中进程能打开的最大文件数目限制



#### 6. epoll 使用流程

1. epoll_create() 返回一个 epfd 文件描述符

2. epoll_ctl(epfd, EPOLL_CTL_ADD, lfd, &ev) 使用创建的 epoll 文件描述符，添加一个节点，该节点指向的文件描述符是 lfd (刚开始创建时，lfd 用作 listen())。当 listen() 监听到内容后，epoll_wait() 会读取到变化，然后把内容返回至 &ev 中。

   > ev: struct epoll_event ev
   >
   > ev.data.fd, ev.event = EPOLLIN

3. epoll_wait(epfd, evs, sz, -1) 阻塞等待 epoll 红黑树中的结点产生变化。

   evs 是 struct epoll_event[1024]，会将发生变化的结点的 fd 返回至这个数组中。程序员可以查询该数组，然后读取变化的 fd， 然后取出，进行相应的业务代码响应。

   

#### 7. epoll: 水平触发模式 (LT)

内核通知使用者哪些文件描述符已经就绪，之后就可以对这些已就绪的文件描述符进行 IO 操作了。

具体来说，

读事件：如果文件描述符对应的缓冲区内还有数据，读事件就会触发，epoll_wait 解除阻塞。比如，接收到的数据的大小大于缓冲区时，读事件会被反复触发，直到数据被全部读出。

写事件：如果文件描述符对应的写缓冲区可写，写事件就会被触发，epoll_wait 解除阻塞。如果缓冲区没有写满，会被一直触发。**因为写数据是主动的，并且写缓冲区一般情况下都是可写的（缓冲区不满），因此对于写事件的检测不是必须的。**



#### 8. epoll: 边沿触发模式 (ET)

这是一种高速工作模式，只支持非阻塞形式。**当文件描述符从未就绪变为就绪时，内核会通过epoll通知使用者。然后它会假设使用者知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知（only once）。**

读事件：当读缓冲区有新的数据进入，读事件被触发一次，没有新数据不会触发该事件。因此，如果接收的数据长度大于缓冲区，它不会反复读出。

写事件：当写缓冲区状态可写，写事件只会触发一次。

- 如果写缓冲区被检测到可写，写事件被触发，epoll_wait () 解除阻塞

- 写事件被触发，就可以通过调用 write ()/send () 函数，将数据写入到写缓冲区中
  - 写缓冲区从不满到被写满，期间写事件只会被触发一次
  - 写缓冲区从满到不满，状态变为可写，写事件只会被触发一次



#### 9. 水平触发与边缘触发

水平触发(level-trggered)

- 只要文件描述符关联的读内核缓冲区非空，有数据可以读取，就一直发出可读信号进行通知，
- 当文件描述符关联的内核写缓冲区不满，有空间可以写入，就一直发出可写信号进行通知

边缘触发(edge-triggered)

- 当文件描述符关联的读内核缓冲区由空转化为非空的时候，则发出可读信号进行通知，
- 当文件描述符关联的内核写缓冲区由满转化为不满的时候，则发出可写信号进行通知



