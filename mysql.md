[TOC]



## 0 Mysql

MySQL是一个关系型数据库，它采用表的形式来存储数据，有行和列，行代表一行数据，列代表属性。

范式：1NF，2NF，3NF

1NF：确保数据库表字段的原子性。 字段必须不可拆分

2NF：满足1NF上，需要表有主键，非主键的列必须完全依赖于主键，而不能依赖于主键的某一部分

3NF：满足2NF上，非主键必须直接依赖主键，不能传递依赖

## 1 Mysql优点

成熟稳定，功能完善。开源免费。文档丰富，既有详细的官方文档，又有非常多优质文章可供参考学习。开箱即用，操作简单，维护成本低。兼容性好，支持常见的操作系统，支持多种开发语言。社区活跃，生态完善。事务支持优秀， InnoDB 存储引擎默认使用 可重复读 并不会有任何性能损失，支持分库分表、读写分离、高可用。

## 2 SQL 语句执行流程和架构

 MySQL 主要由下面几部分构成：简单来说 MySQL 主要分为 Server 层（前五层）和存储引擎层：

- **连接器：** 负责处理客户端与服务端的连接请求，验证用户身份，建立连接后将请求转发给下一个组件
- **查询缓存：** 执行查询语句的时候，会先查询缓存。
- **分析器：** 对客户端发送的 SQL 语句进行语法分析，确定语句类型，并将其转化为 MySQL 内部的执行计划
- **优化器：** 对 SQL 语句进行优化，生成最优的执行计划，主要涉及索引的选择、连接算法的选择、查询语句的重写等
- **执行器：** 根据优化器生成的执行计划，执行 SQL 语句，并返回结果给客户端。执行器会检查用户对表的操作权限，然后调用存储引擎的接口来操作表。
- **存储引擎** ： 负责数据的存储和读写。MySQL 的存储引擎是可插拔的，支持多种存储引擎，如 InnoDB、MyISAM 等

查询语句的执行流程如下：权限校验--->查询缓存-（如果命中缓存就返回）->分析器（词法分析 提取关键元素 select、表名、列、语法问题）--->优化器（化器根据自己的优化算法选择执行效率最好的方案）--->权限校验--->执行器（调用引擎接口）--->引擎返回执行结果

更新（增删改）语句执行流程如下：分析器、权限校验、执行器、引擎、`redo log`（`prepare`状态）、`binlog`、`redo log`（`commit`状态）

查数据，写数据的时候把数据保存在内存中，记录redo log（**重做日志 InnoDB 自带**）(设为prepare 状态)，然后执行器收到消息redo log准备好后，记录binlog**二进制日志**，调用引擎接口，redo log 变为commit状态。   就是先查到数据。然后修改，然后调用引擎接口写数据，记录redo log状态变为prepare告诉执行器可以提交了，然后执行器记录binlog，调用引擎接口，提交redo log 状态变为提交

为什么记录完`redo log`，不直接提交，而是先进入`prepare`状态？

假设先写`redo log`直接提交，然后写`binlog`，写完`redo log`后，机器挂了，`binlog`日志没有被写入，那么机器重启后，这台机器会通过`redo log`恢复数据，但是这个时候`binlog`并没有记录该数据，后续进行机器备份的时候，就会丢失这一条数据，同时主从同步也会丢失这一条数据。

## 3 存储引擎

用的InnoDB，可以比较下MyISAM

### 存储引擎架构

MySQL 存储引擎采用的是 **插件式架构** ，支持多种存储引擎，我们甚至可以为不同的数据库表设置不同的存储引擎以适应不同场景的需要。**存储引擎是基于表的，而不是数据库。**

### MyISAM 和 InnoDB

InnoDB 支持行级别的锁粒度，MyISAM 不支持，只支持表级别的锁粒度。

MyISAM 不提供事务支持。InnoDB 提供事务支持，实现了 SQL 标准定义了四个隔离级别。

MyISAM 不支持外键，而 InnoDB 支持。

MyISAM 不支持 MVCC，而 InnoDB 支持。

索引实现不一样：虽然 MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，InnoDB是聚簇的，myisam是非聚簇的。

MyISAM 不支持数据库异常崩溃后的安全恢复，而 InnoDB 支持。

## 4 MySQL索引

索引是存储引擎用于提高数据库表的访问速度的一种数据结构，帮助我们快速找到记录。常见的索引结构有:B+树 和 Hash。在 MySQL 中，无论是 Innodb 还是 MyIsam，都使用了 B+树作为索引结构。

### 索引的优缺点

**优点** ：

1. 提高查询效率：使用索引可以大大减少查询所需的时间，因为索引可以快速定位所需数据的位置。
2. 提高数据完整性：通过在表上创建唯一索引，可以确保在插入新数据时不会出现重复数据。

**缺点** ：

1. 增加了数据存储的复杂度：每个索引需要额外的存储空间，如果表中有多个索引，会占用更多的存储空间。
2. 减缓数据更新速度：在更新表中的数据时，索引也必须更新。这可能会导致更新操作变慢，尤其是在使用大型表的情况下。
3. 降低插入数据的速度：在插入新数据时，如果表上有多个索引，插入数据的速度会变慢，因为每个索引也必须更新。

**使用索引一定能提高查询性能吗?**

大多数情况下，索引查询都是比全表扫描要快的。但是如果数据库的数据量不大，那么使用索引也不一定能够带来很大提升。

**索引的作用**：

数据是存储在磁盘上的，如果没有索引，在查询数据的时候会加载所有的数据到内存，依次进行检索，读取磁盘次数较多。有了索引，就不需要加载所有数据，因为B+树的高度一般在2-4层，最多只需要读取2-4次磁盘，查询速度大大提升

### 什么情况下需要建和不建索引

1. 经常用于查询的字段
2. 经常需要排序和分组的字段建立索引，因为索引已经排好序，可以加快排序查询速度
3. 经常用于连接的字段建立索引，可以加快连接的速度（快速定位数据行，不需要扫描整表）

1. where条件中用不到的字段不适合建立索引
2. 表记录较少。比如只有几百条数据，没必要加索引。
3. 需要经常增删改。
4. 区分度不高的字段不适合建立索引，如性别，只有男/女/未知三个值。加了索引，查询效率也不会提高

### 索引的数据结构

**Hash** 表

哈希表是键值对的集合，通过键(key)即可快速取出对应的值(value)，因此哈希表可以快速检索数据（接近 O（1））。用哈希算法（散列算法）找key的位置，用链表解决hash冲突

既然哈希表这么快，**为什么 MySQL 没有使用其作为索引的数据结构呢？** 主要是因为 Hash 索引不支持顺序和范围查询。假如我们要对表中的数据进行排序或者进行范围查询，那 Hash 索引可就不行了。并且，每次 IO 只能取一个。

**B 树& B+树**

B 树也称 B-树,全称为 **多路平衡查找树** ，B+ 树是 B 树的一种变体。

目前大部分数据库系统及文件系统都采用 B-Tree 或其变种 B+Tree 作为索引结构。

**B 树& B+树两者有何异同，为什么选B+**

B 树的所有节点既存放键(key) 也存放 数据(data)，而 B+树只有叶子节点存放 key 和 data，其他节点只存放 key。

由于B+树的数据都存储在叶子结点中，叶子结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，而在数据库中基于范围的查询是非常频繁的，所以通常B+树用于数据库索引

B 树的叶子节点互相独立的;B+树的叶子节点有一条引用链指向与它相邻的叶子节点。

因为B树其他结点村有数据，所以有可能在上搜索的时候在中间就终止了。而 B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。

### 红黑树插入过程

1. 将新节点插入到红黑树中，颜色标记为红色。
2. 如果新节点的父节点是黑色的，则插入操作完成，否则执行下一步操作。
3. 如果新节点的父节点是红色的，需要进行颜色调整和旋转来保证红黑树的性质不被破坏。
   - 如果新节点的叔节点是红色的，将父节点和叔节点的颜色改为黑色，将祖父节点的颜色改为红色，并以祖父节点为当前节点重复步骤2。
   - 如果新节点的叔节点是黑色的或者不存在，具体来说，有以下两种情况：
     - 左旋：如果新节点是其父节点的右子节点，并且父节点是其祖父节点的左子节点，则进行左旋操作和右旋，同时将新节点的颜色改为黑色，父节点的颜色和祖父都改为红色，如果父节点是其祖父节点的右子节点，左旋，涂色
     - 右旋：如果新节点是其父节点的左子节点，并且父节点是其祖父节点的右子节点，则进行右旋和左旋操作，同时将新节点的颜色改为黑色，父节点的颜色和祖父都改为红色。如果父节点是其祖父节点的做子节点，右旋，涂色
4. 最后，将根节点的颜色改为黑色，以保证红黑树的性质不被破坏。

### B+树插入过程

B+树插入的核心过程可以简单概括为以下几个步骤：

1. 从根节点开始搜索，找到要插入的叶子节点。
2. 在叶子节点中插入新的关键字，并保持节点中关键字的有序性。
3. 如果插入后叶子节点的关键字个数超过了最大允许的关键字个数，则进行节点分裂操作。
4. 将分裂后的新节点插入到父节点中，并保持父节点中关键字的有序性。
5. 如果插入后父节点的关键字个数超过了最大允许的关键字个数，则递归执行节点分裂操作。

### MyISAM和InnoDB的B+树

MyISAM 引擎中，是非聚集索引。B+Tree 叶节点的 data 域存放的是**数据记录的地址**。在索引检索的时候，首先按照 B+Tree 搜索算法搜索索引，如果指定的 Key 存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。

InnoDB 引擎中，是聚集索引，物理上的相邻，一个表只能有一个聚簇索引，其数据文件本身就是索引文件。表数据文件本身就是按 B+Tree 组织的一个索引结构，树的叶节点 data 域保存了完整的数据记录。

### 聚簇索引与非聚簇索引

聚集索引定义了表的物理顺序，使得相邻的行在物理存储上也相邻。因此，聚集索引的叶节点包含了整个表的数据行，因为表的数据行也是按照聚集索引的排序顺序存储的。由于聚集索引决定了数据的物理存储方式，因此每个表只能有一个聚集索引。通常，聚集索引会在主键上创建，但也可以在唯一非空列上创建。在查询时，使用聚集索引可以提高查询性能，因为数据行的物理存储顺序与索引的排序顺序一致，可以减少磁盘 I/O 的次数。但是，在插入、更新和删除数据时，由于要维护数据行的物理顺序，可能会导致性能下降

**优点** ：

- 对主键的查询速度很快。
- 数据行物理上按照主键的顺序存储，可以减少磁盘IO。

**缺点** ：

- 对于频繁更新、插入、删除的表，聚簇索引的维护代价较高。
- 聚簇索引只能有一个，因此在多个查询需要不同排序的情况下，可能无法充分利用索引。

非聚集索引在物理存储上，数据行的顺序与索引的排序顺序不一定一致。因此，非聚集索引的叶节点存储了索引列的值以及指向对应数据行的指针，而不是存储整个数据行。这样，可以通过非聚集索引快速定位到符合条件的数据行，并通过指针访问数据行的其他列。一个表可以有多个非聚集索引，因为它们只影响数据行的逻辑顺序，不影响数据行的物理存储顺序

**优点** ：

- 对非主键列的查询速度很快。
- 可以创建多个非聚簇索引。

**缺点** ：

- 查询需要进行多次磁盘IO，因此查询速度可能较慢。
- 非聚簇索引的键值可能比聚簇索引更大，因此占用更多的存储空间。
- 可能会二次查询(回表) ： 当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。

**非聚簇索引一定回表查询吗**(覆盖索引)?

不一定，如果查的就是那个属性，select a from b where a= 'xx'； 这就不用了

### 索引类型

按照底层存储方式角度划分：

- 聚簇索引（聚集索引）：索引结构和数据一起存放的索引，InnoDB 中的主键索引就属于聚簇索引。
- 非聚簇索引（非聚集索引）：索引结构和数据分开存放的索引，二级索引(辅助索引)就属于非聚簇索引。MySQL 的 MyISAM 引擎，不管主键还是非主键，使用的都是非聚簇索引。

按照应用维度划分：

- 主键索引：加速查询 + 列值唯一（不可以有 NULL）+ 表中只有一个。
- 普通索引：仅加速查询。
- 唯一索引：加速查询 + 列值唯一（可以有 NULL）。
- 覆盖索引：那个索引包含所有需要查询的字段的值。
- 组合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并。
- 全文索引：对文本的内容进行分词，进行搜索。目前只有 `CHAR`、`VARCHAR` ，`TEXT` 列上可以创建全文索引。一般不会使用，效率较低，通常使用搜索引擎如 ElasticSearch 代替。

### 最左前缀匹配原则

最左前缀原则，只有从索引最左边开始的连续一段索引列才能被加速，或者到某个字段遇到范围查询也会停止匹配，like > < 这种，对`(a,b,c,d)`建立索引，查询条件为`a = 1 and b = 2 and c > 3 and d = 4`，那么a、b和c三个字段能用到索引，而d无法使用索引。因为遇到了范围查询

### 主键索引

数据表的主键列使用的就是主键索引。一张数据表有只能有一个主键，并且主键不能为 null，不能重复。

在 MySQL 的 InnoDB 的表中，当没有显示的指定表的主键时，InnoDB 会自动先检查表中是否有唯一索引且不允许存在 null 值的字段，如果有，则选择该字段为默认的主键，否则 InnoDB 将会自动创建一个 6Byte 的自增主键

### 二级索引

二级索引又称为辅助索引，是因为二级索引的叶子节点存储的数据是主键。也就是说，通过二级索引，可以定位主键的位置。唯一索引，普通索引，前缀索引等索引属于二级索引。

1. **唯一索引(Unique Key)** ：唯一索引也是一种约束。**唯一索引的属性列不能出现重复的数据，但是允许数据为 NULL，一张表允许创建多个唯一索引。** 建立唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效率。
2. **普通索引(Index)** ：普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和 NULL。
3. **前缀索引(Prefix)** ：前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小， 因为只取前几个字符。
4. **全文索引(Full Text)** ：全文索引主要是为了检索大文本数据中的关键字的信息，是目前搜索引擎数据库使用的一种技术。

### 覆盖索引

覆盖索引 ：一个索引包含所有需要查询的字段的值。覆盖索引即需要查询的字段正好是索引的字段，那么直接根据该索引，就可以查到数据了，而无需回表查询 。InnoDB 存储引擎中，如果不是主键索引，叶子节点存储的是主键+列值。最终还是要“回表”，也就是要通过主键再查找一次。这样就会比较慢，覆盖索引就是把要查询出的列和索引是对应的，不做回表操作！

可不说：不是所有类型的索引都可以成为覆盖索引。覆盖索引要存储索引列的值，而哈希索引、全文索引不存储索引列的值，所以MySQL使用b+树索引做覆盖索引。

对于使用了覆盖索引的查询，在查询前面使用**explain**，输出的extra列会显示为`using index`。

比如`user_like` 用户点赞表，组合索引为`(user_id, blog_id)`

```mysql
explain select blog_id from user_like where user_id = 13;
```

`explain`结果的`Extra`列为`Using index`，查询的列被索引覆盖，并且where筛选条件符合最左前缀原则，通过**索引查找**就能直接找到符合条件的数据，不需要回表查询数据。

```mysql
explain select user_id from user_like where blog_id = 1;
```

`explain`结果的`Extra`列为`Using where; Using index`， 查询的列被索引覆盖，where筛选条件不符合最左前缀原则，无法通过索引查找找到符合条件的数据，但可以通过**索引扫描**找到符合条件的数据，也不需要回表查询数据。

### 前缀索引

有时需要在很长的字符列上创建索引，这会造成索引特别大且慢。前缀索引是指对文本或者字符串的前几个字符建立索引，这样索引的长度更短，查询速度更快。

### 索引下推

没有利用索引下推时，通过使用非主键索引进行查询的时候，存储引擎通过索引查询数据，然后将结果返回给server层，在server层判断是否符合条件。利用了之后，当存在索引的列做为判断条件时，server层将这一部分判断条件传递给存储引擎，然后存储引擎会筛选出符合条件的索引项，然后回表查询得到结果，将结果返回给MySQL server。也就是说存储引擎层会在回表查询之前对数据进行过滤，可以减少存储引擎回表查询的次数。

联合索引：name, level

以前：查询条件`name LIKE "大%" `不是等值匹配，根据**最左匹配原则**，在`(name, level)`索引树上只用到`name`去匹配，查找到两条记录（id为1和4），拿到这两条记录的id分别回表查询，然后将结果返回给MySQL server，在MySQL server层进行`level`字段的判断。**整个过程需要回表2次**。

，多了索引下推的优化，在索引遍历过程中，对**索引中的字段**先做判断，过滤掉不符合条件的索引项，**也就是判断level是否等于1**，level不为1则直接跳过。因此在`(name, level)`索引树只匹配一个记录（id=1），之后拿着此记录对应的id回表查询全部数据，**整个过程回表1次**。

可以使用explain查看是否使用索引下推，当`Extra`列的值为`Using index condition`，则表示使用了索引下推。

### 正确使用索引的一些建议

**选择合适的字段创建索引**

- **不为 NULL 的字段** ：索引字段的数据应该尽量不为 NULL，因为对于数据为 NULL 的字段，数据库较难优化。如果字段频繁被查询，但又避免不了为 NULL，建议使用 0,1,true,false 这样语义较为清晰的短值或短字符作为替代。
- **被频繁查询的字段** ：我们创建索引的字段应该是查询操作非常频繁的字段。
- **被作为条件查询的字段** ：被作为 WHERE 条件查询的字段，应该被考虑建立索引。
- **频繁需要排序的字段** ：索引已经排序，这样查询可以利用索引的排序，加快排序查询时间。
- **被经常频繁用于连接的字段** ：经常用于连接的字段可能是一些外键列，对于外键列并不一定要建立外键，只是说该列涉及到表与表的关系。对于频繁被连接查询的字段，可以考虑建立索引，提高多表连接查询的效率。
- 尽量使用**短索引**，对于较长的字符串进行索引时应该指定一个较短的前缀长度，因为较小的索引涉及到的磁盘I/O较少，查询速度更快。

**被频繁更新的字段应该慎重建立索引**

虽然索引能带来查询上的效率，但是维护索引的成本也是不小的。 如果一个字段不被经常查询，反而被经常修改，那么就更不应该在这种字段上建立索引了。

**限制每张表上的索引数量**

索引并不是越多越好，建议单张表索引不超过 5 个！索引可以提高效率同样可以降低效率。索引可以增加查询效率，但同样也会降低插入和更新的效率，甚至有些情况下会降低查询效率。因为 MySQL 优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，就会增加 MySQL 优化器生成执行计划的时间，同样会降低查询性能。

**尽可能的考虑建立联合索引而不是单列索引**

因为索引是需要占用磁盘空间的，可以简单理解为每个索引都对应着一颗 B+树。如果一个表的字段过多，索引过多，那么当这个表的数据达到一个体量后，索引占用的空间也是很多的，且修改索引时，耗费的时间也是较多的。如果是联合索引，多个字段在一个索引上，那么将会节约很大磁盘空间，且修改数据的操作效率也会提升。

**注意避免冗余索引**

冗余索引指的是索引的功能相同，能够命中索引(a, b)就肯定能命中索引(a) ，那么索引(a)就是冗余索引。如（name,city ）和（name ）这两个索引就是冗余索引，能够命中前者的查询肯定是能够命中后者的 在大多数情况下，都应该尽量扩展已有的索引而不是创建新索引。

**字符串类型的字段使用前缀索引代替普通索引**

前缀索引仅限于字符串类型，较普通索引会占用更小的空间，所以可以考虑使用前缀索引带替普通索引。

### 索引失效

索引失效也是慢查询的主要原因之一，常见的导致索引失效的情况有下面这些：

- 使用 `SELECT *` 进行查询;
- 创建了组合索引，但查询条件未遵守最左匹配原则;
- 在索引列上进行计算等操作;
- 以 `%` 开头的 LIKE 查询比如 `like '%abc'`;非%开头的like查询如`abc%`，相当于范围查询，会使用索引
- 查询条件中使用 or，且 or 的前后条件中有一个列没有索引，涉及的索引都不会被使用到;
- 判断索引列是否不等于某个值时

## 5 MySQL 查询缓存

**查询缓存不命中的情况：**

1. 任何两个查询在任何字符上的不同都会导致缓存不命中。
2. 如果查询中包含任何用户自定义函数、存储函数、用户变量、临时表、MySQL 库中的系统表，其查询结果也不会被缓存。
3. 缓存建立之后，MySQL 的查询缓存系统会跟踪查询中涉及的每张表，如果这些表（数据或结构）发生变化，那么和这张表相关的所有缓存数据都将失效。

**缓存虽然能够提升数据库的查询性能，但是缓存同时也带来了额外的开销，每次查询后都要做一次缓存操作，失效后还要销毁。** 因此，开启查询缓存要谨慎，尤其对于写密集的应用来说更是如此。如果开启，要注意合理控制缓存空间大小，一般来说其大小设置为几十 MB 比较合适。

**推荐用本地缓存或者分布式缓存**

简单总结一下查询缓存的**适用场景**：

- 表数据修改不频繁、数据较静态。
- 查询（Select）重复度高。
- 查询结果集小于 1 MB。

简单总结一下查询缓**存不适用的场景**：

- 表中的数据、表结构或者索引变动频繁
- 重复的查询很少
- 查询的结果集很大

## 6 MySQL 日志

MySQL InnoDB 引擎使用 **redo log(重做日志)** 保证事务的**持久性**，使用 **undo log(回滚日志)** 来保证事务的**原子性**。

`MySQL`数据库的**数据备份、主备、主主、主从**都离不开`binlog`，需要依靠`binlog`来同步数据，保证数据一致性。

### 常见日志

错误日志（Error Log）：记录了 MySQL 数据库引擎在运行过程中产生的错误信息，包括启动和关闭时的错误，数据库连接错误，SQL 语法错误等。

慢查询日志，记录了执行时间超过一定阈值的 SQL 查询语句，用于识别执行时间较长的查询，以便进行性能优化。

二进制日志（Binary Log）：记录了所有对数据库进行更改的 SQL 语句，包括 INSERT、UPDATE、DELETE 等操作。二进制日志可以用于实现数据备份、复制和恢复等功能，也可以用于实现数据库的点播和回滚。

重做日志（事务日志） redo log，记录了正在进行的事务的更改操作，用于确保数据库的事务安全性和持久性。

回滚日志（Undo Log）：记录了正在进行的事务的回滚操作，用于在事务回滚时还原数据库的更改。

中继日志（Relay Log）：在 MySQL 数据库复制中使用，用于记录主数据库（Master）上产生的二进制日志，并传递给从数据库（Slave）进行复制。

### 慢查询日志

1. 性能优化：慢查询日志可以帮助识别数据库中执行时间较长的查询语句，从而可以通过优化这些查询语句来提高数据库的性能。通过分析慢查询日志，可以找到频繁执行的查询语句，识别可能存在的性能瓶颈，例如未使用索引、复杂的连接或子查询、大量数据扫描等，并针对性地进行优化，从而提升数据库的查询性能。
2. 故障排查：慢查询日志可以帮助识别数据库中可能存在的问题和错误。通过检查慢查询日志，可以找到执行时间较长的查询语句，从而找到可能导致数据库性能下降或错误发生的原因。例如，可能存在死锁、表锁或者索引失效等问题，通过分析慢查询日志可以帮助定位并解决这些问题。
3. 安全审计：慢查询日志还可以用于数据库的安全审计。通过记录查询语句的执行时间和具体执行的SQL语句，可以帮助检测数据库中的异常查询行为，例如未经授权的查询、SQL注入攻击等，并对其进行安全审计和监控。

### redolog

Redo log是InnoDB存储引擎特有的一种日志，记录了事务执行时所做的修改操作。当事务提交时，Redo log会被写入磁盘，以保证数据的持久性。在系统崩溃或重启时，通过Redo log可以恢复到最近的一致状态。Redo log是以物理日志的形式存在，记录的是物理操作。

一开始并不是直接写入磁盘，而是记录到重做日志缓存（`redo log buffer`） 每隔1s 写入到 page cache中里，然后刷盘到 `redo log` 文件里（和写cache是先后的）。

**刷盘时机**（如何保证持久性）

`InnoDB` 存储引擎为 `redo log` 的刷盘，它支持三种策略：

设置为 0 的时候，表示每次事务提交时不进行刷盘操作（如果事务执行完，mysql挂了，就会丢失1s的数据）

设置为 1 的时候，表示每次事务提交时都将进行刷盘操作（默认值）（如果事务没执行完，mysql挂了，也没关系，因为没提交，如果提交就一定会刷盘，但可能会自动提交，导致不一致）

设置为 2 的时候，表示每次事务提交时都只把 redo log buffer 内容写入 page cache（还没有刷盘，要等自动1s）

另外，`InnoDB` 存储引擎有一个后台线程，每隔`1` 秒，就会把 `redo log buffer` 中的内容写到文件系统缓存（`page cache`），然后调用 `fsync` 刷盘。也就是说，一个没有提交事务的 `redo log` 记录，也可能会刷盘。因为在事务执行过程 `redo log` 记录是会写入`redo log buffer` 中，这些 `redo log` 记录会被后台线程刷盘。除了后台线程每秒`1`次的轮询操作，还有一种情况，当 `redo log buffer` 占用的空间即将达到 `innodb_log_buffer_size` 一半的时候，后台线程会主动刷盘。

**日志文件组**

硬盘上存储的 `redo log` 日志文件不只一个，而是以一个**日志文件组**的形式出现的，每个的`redo`日志文件大小都是一样的。

比如可以配置为一组`4`个文件，每个文件的大小是 `1GB`，整个 `redo log` 日志文件组可以记录`4G`的内容。

它采用的是环形数组形式，从头开始写，写到末尾又回到头循环写

在个**日志文件组**中还有两个重要的属性，分别是 写位置和检查点

写位置 是当前记录的位置，一边写一边后移

检查点是当前要擦除的位置，也是往后推移

每次刷盘 `redo log` 记录到**日志文件组**中，写位置就会后移更新。每次 `MySQL` 加载**日志文件组**恢复数据时，会清空加载过的 `redo log` 记录，并把检查点后移。

**页修改之后为什么不直接刷盘呢**

且每次操作就去操作磁盘，影响效率，放到内存里就好一些，减少对磁盘的访问。

`write pos` 和 `checkpoint` 之间的还空着的部分可以用来写入新的 `redo log` 记录。

### binlog 

Binlog是MySQL数据库的日志文件，记录了所有的数据库更新操作。与Redo log不同的是，Binlog是以逻辑日志的形式存在，记录的是逻辑操作，包括数据库中的语句和事件。Binlog主要用于复制和恢复数据，通过读取Binlog可以实现数据的备份和恢复、数据同步等操作。

binlog 中记录的内容包括：

1. 执行的 SQL 语句：binlog 记录了每个修改操作所执行的 SQL 语句，以便在需要时能够还原执行过程。
2. 事务的信息：对于事务性存储引擎，binlog 记录了每个事务的开始、提交、回滚等操作，以保证事务的ACID。
3. 修改的数据：binlog 记录了修改操作所影响的数据，包括修改前和修改后的数据内容，以及修改的位置信息（表名、行号、列名等）。

binlog 在数据备份、数据恢复、数据同步等方面都具有重要作用，尤其是在**主从复制**、数据迁移、数据恢复等场景下更是不可或缺。

`binlog` 日志有**三种格式**，statement（sql语句）、row、mixed但是如果sql语句中有个获取系统时间，那么恢复的时候数据就不一致了，为了解决这种问题，我们需要指定为`row`，记录的内容不再是简单的`SQL`语句了，还包含操作的具体数据，`row`格式记录的内容看不到详细信息，要通过`mysqlbinlog`工具解析出来。`update_time=now()`变成了具体的时间`update_time=1627112756247`，条件后面的@1、@2、@3 都是该行数据第 1 个~3 个字段的原始值（**假设这张表只有 3 个字段**）。这样就能保证同步数据的一致性，通常情况下都是指定为`row`，这样可以为数据库的恢复与同步带来更好的可靠性。但是这种格式，需要更大的容量来记录，比较占用空间，恢复与同步时会更消耗`IO`资源，影响执行速度。所以就有了一种折中的方案，指定为`mixed`，记录的内容是前两者的混合。MySQL会判断这条`SQL`语句是否可能引起数据不一致，如果是，就用`row`格式，否则就用`statement`格式。

**写入机制**

`binlog`的写入时机也非常简单，事务执行过程中，先把日志写到一块内存里，事务提交的时候，再把内存写到`binlog`文件中。因为一个事务的`binlog`不能被拆开，无论这个事务多大，也要确保一次性写入，所以系统会给每个线程分配一个块内存作为`binlog cache`。我们可以通过`binlog_cache_size`参数控制单个线程 binlog cache 大小，如果存储内容超过了这个参数，就要暂存到磁盘（`Swap`）。

**日志刷盘：**

write，是指把日志写入到文件系统的 page cache，并没有把数据持久化到磁盘，所以速度比较快

 fsync，才是将数据持久化到磁盘的操作

`write`和`fsync`的时机，可以由参数`sync_binlog`控制，默认是`0`。为`0`的时候，表示每次提交事务都只`write`，由系统自行判断什么时候执行`fsync`。虽然性能得到提升，但是机器宕机，`page cache`里面的 binlog 会丢失。为了安全起见，可以设置为`1`，表示每次提交事务都会执行`fsync`，就如同 **redo log 日志刷盘流程** 一样。最后还有一种折中方式，可以设置为`N(N>1)`，表示每次提交事务都`write`，但累积`N`个事务后才`fsync`。

### 两段提交

在执行更新语句过程，会记录`redo log`与`binlog`两块日志，以基本的事务为单位，`redo log`在事务执行过程中可以不断写入，而`binlog`只有在提交事务时才写入，所以`redo log`与`binlog`的写入时机不一样。

为了解决两份日志之间的逻辑一致问题，`InnoDB`存储引擎使用**两阶段提交**方案。他们通过事务id来判断同一个事物

原理很简单，将`redo log`的写入拆成了两个步骤`prepare`和`commit`，这就是**两阶段提交**。prepare其实是就是之前的写redo log。写入`binlog`时发生异常也不会有影响，因为`MySQL`根据`redo log`日志恢复数据时，发现`redo log`还处于`prepare`阶段，并且没有对应`binlog`日志，就会回滚该事务

`redo log`设置`commit`阶段发生异常，那会不会回滚事务呢？ 不会，因为此时的binlog有记录

### binlog 和 redolog 区别

1. 内容：binlog中记录了对数据库进行更改的SQL语句，可以通过解析SQL语句来获取更改的具体内容。而redolog中记录了数据库中每个事务的物理修改，包括更改前和更改后的数据。
2. 使用时机：binlog在事务提交时生成，用于记录事务的更改操作。redolog在事务开始时生成，在事务进行是不断写入磁盘。
3. `bin log`是逻辑日志，记录的是SQL语句的原始逻辑；`redo log`是物理日志，记录的是在某个数据页上做了什么修改。
4. Binlog，它包含的信息可以用于数据备份和恢复、数据同步和数据分析等。binlog记录的操作可以用于在主从复制中，将主服务器上的数据同步到从服务器上，从而保证数据的一致性。redolog用于在事务发生故障时进行事务的恢复。
5. Redo log是InnoDB存储引擎特有的一种日志 binlog是mysql数据库级别的

### undo log 

Undo log是数据库中的一种日志，用于支持事务的原子性和一致性。当事务进行修改时，数据库会将这些修改操作记录在Undo log中。如果该事务失败或回滚，数据库会使用Undo log中的信息来撤消（undo）这些修改，使数据库恢复到原始状态，实现MVCC。

### undo 和 redo

undolog和redolog是数据库管理系统中的两个重要日志类型，用于记录数据库的变更操作。它们之间的主要区别如下：

1. Undo Log：也称为回滚日志，用于记录事务的撤销操作。当一个事务执行了修改操作，数据库管理系统会将这些修改操作记录到undolog中，以便在事务回滚时可以撤销这些操作。这样，如果事务执行失败或被回滚，可以使用undolog将数据库恢复到事务开始前的状态。
2. Redo Log：也称为重做日志，用于记录事务的重做操作。当一个事务执行了修改操作，数据库管理系统会将这些修改操作记录到redolog中，以便在事务提交后可以将这些操作重新执行，从而保证事务的持久性。这样，如果数据库发生故障，如断电或崩溃，可以使用redolog将未提交的事务重新执行，从而保护数据库的一致性。

主要区别可以总结如下：

1. Undo Log用于记录事务的撤销操作，Redo Log用于记录事务的重做操作。
2. Undo Log用于事务的回滚原子性，Redo Log用于事务的持久性保证。
3. Undo Log记录的是事务执行前的数据变更操作，Redo Log记录的是事务执行后的数据变更操作。

## 7 MySQL事务

**原子性**（`Atomicity`） ： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；

**一致性**（`Consistency`）： 执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；

**隔离性**（`Isolation`）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；

**持久性**（`Durability`）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。

### 并发事务带来了哪些问题?（什么是脏读、幻读、不可重复读等）

**丢失修改**  在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。

**脏读**  一个事务读取数据并且对数据进行了修改，这个修改对其他事务来说是可见的，即使当前事务没有提交。这时另外一个事务读取了这个还未提交的数据，但第一个事务突然回滚，导致数据并没有被提交到数据库，那第二个事务读取到的就是脏数据，这也就是脏读的由来。

**不可重复读**在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。

**幻读**幻读与不可重复读类似。它发生在一个事务读取了几行数据，接着另一个并发事务插入了一些数据时。在随后的查询中，第一个事务就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。

**不可重复读和幻读区别**

- 不可重复读的重点是内容修改或者记录减少比如多次读取一条记录发现其中某些记录的值被修改；
- 幻读的重点在于记录新增比如多次执行同一条查询语句（DQL）时，发现查到的记录增加了。

### 并发事务的控制

MySQL 中并发事务的控制方式无非就两种：**锁** 和 **MVCC**。锁可以看作是悲观控制的模式，多版本并发控制（MVCC）可以看作是乐观控制的模式。

**锁** 控制方式下会通过锁来显示控制共享资源而不是通过调度手段，MySQL 中主要是通过 **读写锁** 来实现并发控制。

- **共享锁（S 锁）** ：又称读锁，事务在读取记录的时候获取共享锁，允许多个事务同时获取（锁兼容）。
- **排他锁（X 锁）** ：又称写锁/独占锁，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条记录加任何类型的锁（锁不兼容）。

读写锁可以做到读读并行，但是无法做到写读、写写并行。另外，根据根据锁粒度的不同，又被分为 表级锁 和 行级锁 。InnoDB 不光支持表级锁，还支持行级锁，默认为行级锁。行级锁的粒度更小，仅对相关的记录上锁即可（对一行或者多行记录加锁），所以对于并发写入操作来说， InnoDB 的性能更高。不论是表级锁还是行级锁，都存在共享锁（S 锁）和排他锁（X 锁）这两类。

**MVCC** 是多版本并发控制方法，即对一份数据会存储多个版本，通过事务的可见性来保证事务能看到自己应该看到的版本。在 MVCC 中，每个事务看到的数据库状态是一致的，但是不同的事务可能会看到不同的数据版本。

MVCC 在 MySQL 中实现所依赖的手段主要是: **隐藏字段、read view、undo log**。

- undo log : undo log 用于记录某行数据的多个版本的数据。
- read view 和 隐藏字段 : 用来判断当前版本数据的可见性。

### 隔离级别

## **事务隔离级别**

SQL 标准定义了四种隔离级别，MySQL 全都支持。这四种隔离级别分别是：

1. 读未提交（READ UNCOMMITTED）
2. 读提交 （READ COMMITTED）
3. 可重复读 （REPEATABLE READ）
4. 串行化 （SERIALIZABLE）

从上往下，隔离强度逐渐增强，性能逐渐变差。采用哪种隔离级别要根据系统需求权衡决定，其中，**可重复读**是 MySQL 的默认级别。

事务隔离其实就是为了解决上面提到的脏读、不可重复读、幻读这几个问题，下面展示了 4 种隔离级别对这三个问题的解决程度。

![img](mysql_pic/v2-2e1a7203478165890e2d09f36cb39857_1440w.webp)

只有串行化的隔离级别解决了全部这 3 个问题，其他的 3 个隔离级别都有缺陷。



**MySQL 的隔离级别基于锁和 MVCC 机制共同实现的。**

串行化是通过锁来实现的，读已提交和 可重复读是基于 MVCC 实现的。不过，串行化之外的其他隔离级别可能也需要用到锁机制，就比如 可重复读在当前读情况下需要使用加锁读来保证不会出现幻读。

**但是！InnoDB 实现的可重复读其实是可以解决幻读问题发生的，主要有下面两种情况：**

- **快照读** ：由 MVCC 机制来保证不出现幻读。
- **当前读** ： 临键锁（Next-Key Lock）进行加锁来保证不出现幻读，临键锁是记录锁和间隙锁的结合，记录锁只能锁住已经存在的行，为了避免插入新行，需要加入**间隙锁**。

InnoDB 存储引擎在分布式事务的情况下一般会用到 SERIALIZABLE 隔离级别。

### 生产环境数据库一般用读已提交

可重复读使用存在间隙锁去解决幻读，导致出现死锁的几率比读已提交大的多！

可重复读条件列未命中索引会锁表！而在读已提交隔离级别下，只锁行!也就是说，读已提交的并发性高于可重复读。

在重复读隔离级别下，当一个查询需要访问某个表的某些行时，会对这些行进行加锁。如果这些行没有命中索引，就需要锁定整个表，这样其他查询就不能修改这个表中的任何行，导致表锁定。

并且大部分场景下，不可重复读问题是可以接受的。毕竟数据都已经提交了，读出来本身就没有太大问题！

### 解决幻读的方法

解决幻读的方式有很多，但是它们的核心思想就是一个事务在操作某张表数据的时候，另外一个事务不允许新增或者删除这张表中的数据了。解决幻读的方式主要有以下几种：

1. 将事务隔离级别调整为 `SERIALIZABLE` 。
2. 在可重复读的事务级别下，给事务操作的这张表添加表锁。
3. 在可重复读的事务级别下，给事务操作的这张表添加 临键锁  就是记录锁+间隙锁

## 8 MVCC

MVCC多版本并发控制，就是一份数据保留多个版本的一种方式，进而实现并发控制。

作用：提高并发性能：MVCC使多个用户可以同时读取和修改数据库中的数据，保证数据一致性：MVCC技术使用版本控制机制来保证数据的一致性，当一个用户修改了一条数据时，其他用户读取该数据时会看到之前的版本或最新的版本，

### 一致性非锁定读（快照读）

快照读则是读取一个事务开始时的数据库状态的一个快照，即读取时不会加锁，读取的数据可能不是最新的，一般的SELECT就是快照读，通过mvcc来进行并发控制的。

### 一致性锁定读（当前读）

当前读是指读取最新提交的数据，即读取时会加锁，保证读取的数据是最新的。当前读适用于需要读取最新数据的场景，例如更新数据前需要先检查数据的状态。UPDATE、DELETE、INSERT，SELECT … LOCK IN SHARE MODE、SELECT … FOR UPDATE

对记录加 `S` 锁，其它事务也可以加`S`锁，如果加 `x` 锁则会被阻塞。对记录加 `X` 锁，且其它事务不能加任何锁。

快照读情况下，InnoDB通过mvcc机制避免了幻读现象。而`mvcc`机制无法避免当前读情况下出现的幻读现象。因为当前读每次读取的都是最新数据，这时如果两次查询中间有其它事务插入数据，就会产生幻读。

### InnoDB 对 MVCC 的实现

**MVCC** 是多版本并发控制方法，即对一份数据会存储多个版本，通过事务的可见性来保证事务能看到自己应该看到的版本。在 MVCC 中，每个事务看到的数据库状态是一致的，但是不同的事务可能会看到不同的数据版本。

MVCC 是通过在每个数据行上保存多个版本来实现的。当一个事务对一行数据进行修改时，InnoDB 会为该行保存一个新的版本，并将该版本的创建时间记录下来。对于未提交的事务，其他事务不会看到它们所做的修改。这些未提交的修改在事务提交之前不会对其他事务可见。

对于已提交的事务，InnoDB 通过快照来实现一致性读取。每个事务看到的数据库状态是在该事务开始时创建的快照。在执行查询时，InnoDB 会根据查询开始时的时间戳来查找对应的数据版本，并且只返回早于该时间戳的数据版本。

当一个事务需要读取数据行时，InnoDB 会根据该事务的隔离级别来确定哪些数据版本是可见的。如果事务使用的是 可重复读隔离级别，则 InnoDB 只返回在事务开始时存在的数据版本。如果事务使用的是 读已提交隔离级别，则 InnoDB 会返回最新的可见数据版本。

`MVCC` 的实现依赖于：**隐藏字段、Read View、undo log**。

1. 隐藏字段：每个数据行都有一个隐藏字段，用于存储该数据行的最新版本号。当有新的事务对该数据行进行更新或插入时，它会创建一个新的版本，并将隐藏字段更新为新版本的时间戳。
2. Read View：有以下几个字段：**版本号（**事务开始时的版本号）：事务开始时，它会获取一个全局的版本号，然后在它执行期间，只能看到在该版本号之前创建的数据版本。**最早活跃事务id** 小于这个id事务都已经提交，都是可见的，**最大事务id**，表示创建事务时，最大的已经完成的事务id，大于这个就不可见 **活跃事务列表**：其中包含了在该事务开始之前已经启动但尚未提交的所有事务的ID，如果事务id在这里面，也是不可见的，如果是不可见，就从版本链里找这个id的上一个版本，然后继续判断
3. Undo Log是一个用于回滚事务的日志，版本连。在MVCC中，每个事务在对数据库进行修改时，都会先记录一条Undo Log，以便在事务回滚时可以恢复数据库的原始状态。同时，Undo Log也可以用于回滚其他事务对该记录的修改，从而实现了MVCC中的多版本并发控制机制。

在 `InnoDB` 存储引擎中 `undo log` 分为两种： `insert undo log` （事务提交后可以删除）和 `update undo log`

### 数据可见性算法

在 `InnoDB` 存储引擎中，创建一个新事务后，执行每个 `select` 语句前，都会创建一个快照（Read View），**快照中保存了当前数据库系统中正处于活跃（没有 commit）的事务的 ID 号**。其实简单的说保存的是系统中当前不应该被本事务看到的其他事务 ID 列表（即 m_ids）。当用户在这个事务中要读取某个记录行的时候，`InnoDB` 会将该记录行的 `DB_TRX_ID` 与 `Read View` 中的一些变量及当前事务 ID 进行比较，判断是否满足可见性条件

### **RC 和 RR 隔离级别下 MVCC 的差异**

- 在读已提交 隔离级别下的 **`每次select`** 查询前都生成一个`Read View` ，由于每次查询都会生成read view 所以有可能会导致不可重复读，第一次读还没提交，第二次读 读到了已提交

- 在 可重复读 隔离级别下只在事务开始后 **`第一次select`** 数据前生成一个`Read View`，所以可重复读


### MVCC+Next-key-Lock 防止幻读

在快照读情况下，MySQL通过`mvcc`来避免幻读。

在当前读情况下，MySQL通过`next-key`来避免幻读（加行锁和间隙锁来实现的）。

`InnoDB`存储引擎在 可重复读 级别下通过 `MVCC`和 `Next-key Lock` （临键锁）来解决幻读问题：

**1、执行普通 `select`，此时会以 `MVCC` 快照读的方式读取数据**

在快照读的情况下，可重复读 隔离级别只会在事务开启后的第一次查询生成 `Read View` ，并使用至事务提交。所以在生成 `Read View` 之后其它事务所做的更新、插入记录版本对当前事务并不可见，实现了可重复读和防止快照读下的 “幻读”

**2、在当前读下，会有幻读**

在当前读下，读取的都是最新的数据，如果其它事务有插入新的记录，并且刚好在当前事务查询范围内，就会产生幻读！InnoDB 使用 临键锁来防止这种情况。当执行当前读时，会锁定读取到的记录的同时，锁定它们的间隙，防止其它事务在查询范围内插入数据。

## 9 MySQL 锁

### 表级锁和行级锁

MyISAM 仅仅支持表级锁，一锁就锁整张表，这在并发写的情况下性非常差。InnoDB 不光支持表级锁，还支持行级锁，默认为行级锁。

行级锁的粒度更小，仅对相关的记录上锁即可（对一行或者多行记录加锁），所以对于并发写入操作来说， InnoDB 的性能更高。

**表级锁和行级锁对比** ：

- **表级锁：** MySQL 中锁定粒度大，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。不过，触发锁冲突的概率最高，高并发下效率极低。表级锁和存储引擎无关，MyISAM 和 InnoDB 引擎都支持表级锁。针对非索引字段加的锁
- **行级锁：** MySQL 中锁定粒度最小的一种锁 ，只针对当前操作的行记录进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。行级锁和存储引擎有关，是在存储引擎层面实现的。针对索引字段加的锁

### 行级锁注意事项

InnoDB 的行锁是针对索引字段加的锁，表级锁是针对非索引字段加的锁。执行修改语句时，如果条件中字段没有命中唯一索引或者索引失效的话，就会导致扫描全表对表中的所有行记录进行加锁。

### 行锁分类

#### 间隙、记录、临键锁

**记录锁**：属于单个行记录上的锁。

**间隙锁** ：锁定一个范围，不包括记录本身。

**临键锁**（Next-Key Lock）：记录锁+间隙锁，锁定一个范围，包含记录本身，主要目的是为了解决幻读问题。记录锁只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁。

在 InnoDB 默认可重复读下，行锁默认使用的是 临键锁。但是，如果操作的索引是唯一索引或主键，InnoDB 会对 临键锁 进行优化，将其降级为记录所，即仅锁住索引本身，而不是范围。

**临键锁的加锁范围**：

1. 当前索引记录：锁定当前索引记录可以确保其他事务无法修改或删除该记录。
2. 下一个索引记录之间的间隙：锁定该间隙可以防止其他事务在这个间隙中插入新记录，从而保证了索引记录的唯一性。

需要注意的是，Next-Key Lock 的加锁范围与索引类型有关，只有使用 B+ 树索引类型的表才会使用 Next-Key Lock 机制，如果是其它类型的索引，如哈希索引，则不会使用 Next-Key Lock。

### 共享锁和排他锁

- **共享锁（S 锁）** ：又称读锁，事务在读取记录的时候获取共享锁，允许多个事务同时获取（锁兼容）。
- **排他锁（X 锁）** ：又称写锁/独占锁，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条事务加任何类型的锁（锁不兼容）。

排他锁与任何的锁都不兼容，共享锁仅和共享锁兼容。

对于INSERT、UPDATE和DELETE，InnoDB 会自动给涉及的数据加排他锁；对于一般的SELECT语句，InnoDB 不会加任何锁，

### 意向锁

如果需要用到表锁的话，如何判断表中的记录没有行锁呢，一行一行遍历肯定是不行，性能太差。我们需要用到一个叫做意向锁的东东来快速判断是否可以对某个表使用表锁。

- **意向共享锁（IS 锁）**：事务有意向对表中的某些记录加共享锁（S 锁），加共享锁前必须先取得该表的 IS 锁。
- **意向排他锁（IX 锁）**：事务有意向对表中的某些记录加排他锁（X 锁），加排他锁之前必须先取得该表的 IX 锁。

**意向锁是有数据引擎自己维护的，用户无法手动操作意向锁，在为数据行加共享/排他锁之前，InooDB 会先获取该数据行所在在数据表的对应意向锁。**

有了IS不能上X，有了IX不能上S和IX，有了S不能上IX和X，有了X都不能上

### 自增锁

关系型数据库设计表的时候，`AUTO_INCREMENT`的列都会涉及到自增锁，如果一个事务正在插入数据到有自增列的表时，会先获取自增锁，拿不到就可能会被阻塞住

## 10 MySQL 性能、慢查询优化

首先！根据EXPLAIN判断sql语句的索引情况

合理建立索引。在合适的字段上建立索引，例如在WHERE和ORDER BY命令上涉及的列建立索引，可根据EXPLAIN来查看是否用了索引还是全表扫描

索引优化，SQL优化。索引要符合最左匹配原则等

数据库优化：可以通过对数据库的参数进行调整来优化查询性能，如增加缓存区大小、调整查询缓存的使用策略等。

分区表：使用分区表来将数据按照一定的规则分割成多个部分，这样在查询时只需要查询指定的分区，可以减少扫描整个表的时间。

利用缓存。利用Redis等缓存热点数据，提高查询效率

读写分离。经典的数据库拆分方案，主库负责写，从库负责读

通过分库分表的方式进行优化，主要有垂直拆分和水平拆分

选择合适的存储引擎：不同的存储引擎有不同的适用场景，如MyISAM适用于读多写少的场景，InnoDB适用于高并发、写多读少的场景。选择合适的存储引擎可以提高查询效率。

**能用 MySQL 直接存储文件（比如图片）吗？**

可以是可以，直接存储文件对应的二进制数据即可。不过，还是建议不要在数据库中存储文件，会严重影响数据库性能，消耗过多存储空间。可以选择使用云服务厂商提供的开箱即用的文件存储服务，成熟稳定，价格也比较低。

**MySQL 如何存储 IP 地址？**

可以将 IP 地址转换成整形数据存储，性能更好，占用空间也更小。

MySQL 提供了两个方法来处理 ip 地址

- `INET_ATON()` ： 把 ip 转为无符号整型 (4-8 位)
- `INET_NTOA()` :把整型的 ip 转为地址

插入数据前，先用 `INET_ATON()` 把 ip 地址转为整型，显示数据时，使用 `INET_NTOA()` 把整型的 ip 地址转为地址显示即可

## 11 MySQL主从同步

MySQL主从同步是一种数据库备份和复制机制，用于将一个MySQL服务器的数据复制到另一个MySQL服务器上。在主从同步中，一个MySQL服务器作为主服务器（Master），它处理所有的写操作并记录它们的二进制日志。另一个MySQL服务器作为从服务器（Slave），它读取主服务器的二进制日志并将其应用到自己的数据库中，从而保持与主服务器的数据一致性。

主从同步有助于提高数据库的可用性和性能。主服务器可以处理写操作，从服务器可以处理读操作，从而分担主服务器的负担。如果主服务器出现故障，从服务器可以接管主服务器的工作，保持服务的连续性。

### 为什么要做主从同步？

1. 数据备份和恢复：主从同步可以实现数据库的实时备份，从而保证数据的安全性和可恢复性。在主服务器上产生的数据变化都会被同步到从服务器，即使主服务器宕机或者发生其他故障，从服务器也可以通过它自身的数据恢复。
2. 提高系统可用性、读写分离：主服务器负责写操作，从服务器负责读操作。从服务器可以作为主服务器的备份，当主服务器发生故障或者需要维护时，从服务器可以立即接管主服务器的工作，从而保证系统的连续性。
3. 提高系统性能：通过主从同步可以提高系统的性能，主服务器只负责写操作，从服务器只负责读操作，可以分担主服务器的负荷，从而提高系统的响应速度和吞吐量。
4. 分布式部署：通过主从同步可以实现分布式部署，主服务器和从服务器可以部署在不同的地理位置或者不同的机房，从而实现数据的异地备份和容灾。

## 12 分库分表

**分库** 就是将数据库中的数据分散到不同的数据库上，可以垂直分库，也可以水平分库。

**分表** 就是对单表的数据进行拆分，可以是垂直拆分，也可以是水平拆分。

从垂直分库分表的角度来看，是将一个大型数据库中的不同业务功能或数据类型分开存储在不同的库中，这些库之间可以通过外键或者其他方式进行关联。垂直分库分表常常应用于复杂的大型系统中，比如社交网络、电商网站等，可以提高系统的并发处理能力，降低单个库的访问压力，提高整个系统的可用性和性能。

**优点**：行记录变小，数据页可以存放更多记录，在查询时减少I/O次数。

**缺点**：

主键出现冗余，需要管理冗余列；

- 会引起表连接JOIN操作，可以通过在业务服务器上进行join来减少数据库压力；
- 依然存在单表数据量过大的问题。

从水平分库分表的角度来看，是将一个大型数据表中的数据根据某种规则拆分成多个子表，每个子表只包含部分数据。水平分库分表常常应用于大数据场景，比如海量用户的日志数据、大规模的传感器数据等，可以提高数据处理能力，降低单个表的访问压力，提高数据读写效率和处理速度。

**优点**：单库（表）的数据量得以减少，提高性能；切分出的表结构相同，程序改动较少。

**缺点**：

- 分片事务一致性难以解决
- 跨节点`join`性能差，逻辑复杂
- 数据分片在扩容时需要迁移

### 什么情况下需要分库分表？

- 单表的数据达到千万级别以上，数据库读写速度比较缓慢。
- 数据热点访问，某些表的数据访问频率特别高，就分散到多个数据库中，访问压力
- 应用的并发量太大。

### 分库分表会带来什么问题呢？

1. 数据一致性问题：由于数据被分散存储在多个数据库或表中，当需要跨多个数据库或表进行操作时，可能会出现数据不一致的情况。
2. 处理分布式事务的复杂性：在分库分表的环境中，涉及到跨多个数据库或表的事务操作会变得更加复杂。例如，如果一个跨多个分库分表的事务出现了故障，那么很难确定哪些数据已经提交，哪些数据需要回滚。
3. 数据迁移和扩容的复杂性：当需要添加新的数据库或表时，需要进行数据迁移和扩容，这可能会导致系统停机时间变长，对业务造成影响。

​    5  join 操作： 同一个数据库中的表分布在了不同的数据库中，导致无法使用 join 操作。这样就导致我们需要手动进行数据的封装，比如你在一个数据库中查询到一个数据之后，再根据这个数据去另外一个数据库中找对应的数据。

分库分表有没有什么比较推荐的方案？：ShardingSphere 除了支持读写分离和分库分表，还提供分布式事务、数据库治理等功能。

### 库分表后，数据怎么迁移呢

1. 停机迁移：停机迁移是指在数据库迁移过程中，需要暂停服务，将原有数据备份并迁移到新的数据库中。这种方式的优点是迁移过程简单，只需要一次性迁移，不会产生数据同步问题。但缺点是需要暂停服务，会对业务产生影响，同时需要考虑备份数据的完整性和安全性。
2. 双写：双写是指在迁移数据的同时，将数据同时写入原有数据库和新的数据库中，保证数据的一致性。这种方式的优点是不需要停机，可以实现实时同步数据，业务不会受到影响。但缺点是需要增加数据同步的复杂度，可能会增加系统负担和网络带宽消耗。

### 什么是分区表

分区表是指在数据库中的一个表，该表的数据根据一定的规则被分成多个区域，每个区域可以单独进行管理、查询和维护。每个区域包含了一定的数据行，而这些数据行之间的区分是根据一个或多个列值的范围、列表或哈希算法来确定的。

分区表的使用可以提高数据库的性能和管理效率。它可以减少查询数据的时间，提高查询速度，同时也可以降低表维护的难度，因为可以对每个区域进行单独的备份、恢复、优化和维护操作。例如，对于一个包含了历史记录的表，可以按照时间进行分区，每个区域代表一个时间段，这样可以避免在查询历史数据时扫描整个表，提高查询效率。

分区表通常需要在创建表时指定分区方式，并且也可以在以后通过修改表结构来添加、删除或调整分区。常见的分区方式有范围分区、哈希分区、列表分区等。具体选择哪种方式取决于数据的特点和查询需求。

### 常见的分区/片算法有哪些？

分片算法主要解决了数据被水平分片之后，数据究竟该存放在哪个表的问题。

- **哈希分片** ：求指定 key 的哈希，然后根据哈希值确定数据应被放置在哪个表中。哈希分片比较适合随机读写的场景，不太适合经常需要范围查询的场景。
- **范围分片** ：按照特性的范围区间（比如时间区间、ID区间）来分配数据，比如 将 `id` 为 `1~299999` 的记录分到第一个库， `300000~599999` 的分到第二个库。范围分片适合需要经常进行范围查找的场景，不太适合随机读写的场景（数据未被分散，容易出现热点数据的问题）。
- **地理位置分片** ：很多 NewSQL 数据库都支持地理位置分片算法，也就是根据地理位置（如城市、地域）来分配数据。
- **融合算法** ：灵活组合多种分片算法，比如将哈希分片和范围分片组合。可以同时保证数据的均衡性和连续性。
- 随机分片算法：将数据随机分配到不同的分片中。这种方法可以保证数据的均衡性和分布的随机性，但对于查询效率可能会有一定的影响。
- 列表分区：和范围差不多，但是他可以不是连续的

### 分区的问题

1. 增加了数据库管理的复杂性，当查询需要跨越多个分区时，分区查询性能下降
2. 维护分区的成本可能很高。例如重组分区，会先创建一个临时分区，然后将数据复制到其中，最后再删除原分区。
3. 所有分区必须使用相同的存储引擎

## 13 自增主键

### 好处

1. 唯一性：自增主键确保每个记录都有一个唯一的标识符，这可以避免出现重复的记录。
2. 快速查找：使用自增主键可以提高查询速度，因为数据库管理系统可以通过使用主键快速查找数据。这是因为自增主键的值是按照顺序增加的，使得在查询时可以更快地定位到所需的数据。
3. 更好的性能：使用自增主键可以提高数据库的性能，因为在插入新记录时，数据库管理系统不需要执行任何复杂的操作来生成主键值。
4. 尽可能保证主键递增顺序插入

### 自增主键保存在什么地方

- MyISAM引擎的自增值保存在数据文件中。
- 在MySQL8.0以前，InnoDB引擎的自增值是存在内存中。MySQL重启之后内存中的这个值就丢失了，每次重启后第一次打开表的时候，会找自增值的最大值max(id)，然后将最大值加1作为这个表的自增值；MySQL8.0版本会将自增值的变更记录在redo log中，重启时依靠redo log恢复。

### 自增主键不一定连续

MySQL自增主键并不一定是连续的。虽然自增主键的初始值和步长都是默认的1，但是在以下情况下，自增主键可能不连续：

1. 如果在插入数据时发生了错误，导致自增主键的值并没有被使用，那么该值就会被浪费，下一个插入数据时就会跳过该值。
2. 在使用InnoDB存储引擎时，如果数据库中存在多个插入事务同时插入数据，那么每个事务可能会分配不同的自增主键值，从而导致主键不连续。
3. 自增初始值和步长不设置1
4. 事务回滚，也会使得主键没有被利用，跳过那个主键

### 自增值为什么不能回收

在一个表中删除了某些行后，该表的自增计数器值并不会回收利用，而是会一直递增下去。好处是可以避免因为回收自增值而引起的锁竞争问题，也可以保证自增值的唯一性。但同时也带来了一些问题比如说当表中的数据经常删除时，会导致自增值的浪费，从而降低了InnoDB的存储效率。

主要为了提升插入数据的效率和并行度。

如果a和b事务，申请到了4和5的id，此时自增值为6，但是a回退了，如果自增id变回4那么，再申请两次就会主键冲突，

而为了解决这个主键冲突，有两种方法：

- 每次申请 id 之前，先判断表里面是否已经存在这个 id。如果存在，就跳过这个 id。但是会让申请id的效率降低。
- 把自增 id 的锁范围扩大，必须等到一个事务执行完成并提交，下一个事务才能再申请自增 id。这个方法的问题会导致系统并发能力大大下降。

这两个方法都会导致性能问题。所以就设计成不可以回收

## 14 MySQL时间类型

不要用字符串，字符串占用的空间更大！字符串存储的日期效率比较低（逐个字符进行比对），无法用日期相关的 API 进行计算和比较

### Datetime 和 Timestamp 之间抉择

首选 **Timestamp**

①**DateTime 类型是没有时区信息的（时区无关）** ，DateTime 类型保存的时间都是当前会话所设置的时区对应的时间。这样就会有什么问题呢？当你的时区更换之后，比如你的服务器更换地址或者更换客户端连接时区设置的话，就会导致你从数据库中读出的时间错误。不要小看这个问题，很多系统就是因为这个问题闹出了很多笑话。

**Timestamp 和时区有关**。Timestamp 类型字段的值会随着服务器时区的变化而变化，自动换算成相应的时间，说简单点就是在不同时区，查询到同一个条记录此字段的值会不一样。

②**DateTime 类型耗费空间更大**

Timestamp 只需要使用 4 个字节的存储空间，但是 DateTime 需要耗费 8 个字节的存储空间（5.6之后占用5字节）。但是，这样同样造成了一个问题，Timestamp 表示的时间范围更小。

如果存进NULL，两者实际存储的值不同。

- TIMESTAMP：会自动存储当前时间 now() 。
- DATETIME：不会自动存储当前时间，会直接存入 NULL 值。

### 数值型时间戳是更好的选择吗？

很多时候，我们也会使用 int 或者 bigint 类型的数值也就是时间戳来表示时间。

这种存储方式的具有 Timestamp 类型的所具有一些优点，并且使用它的进行日期排序以及对比等操作的效率会更高，跨系统也很方便，毕竟只是存放的数值。缺点也很明显，就是数据的可读性太差了，你无法直观的看到具体时间。

## 15 隐式转换导致索引失效

当操作符**左右两边的数据类型不一致**时，会发生**隐式转换**。

当 where 查询操作符**左边为数值类型**时发生了隐式转换，那么对效率影响不大，但还是不推荐这么做。

当 where 查询操作符**左边为字符类型**时发生了隐式转换，那么会导致索引失效，造成全表扫描效率极低。

字符串转换为数值类型时，非数字开头的字符串会转化为`0`，以数字开头的字符串会截取从第一个字符到第一个非数字内容为止的值为转化结果。

所以，我们在写 SQL 时一定要养成良好的习惯，查询的字段是什么类型，等号右边的条件就写成对应的类型。特别当查询的字段是字符串时，等号右边的条件一定要用引号引起来标明这是一个字符串，否则会造成索引失效触发全表扫描。

## 16 exist和in的区别

`EXISTS` 用于检查子查询是否返回了任何行。如果子查询返回了至少一行，那么 `EXISTS` 的结果为真，否则为假。在使用 `EXISTS` 时，通常不需要知道子查询返回了哪些具体的行，只需要知道是否存在满足条件的行即可

`IN` 用于比较一个表达式是否在一个值列表或子查询的结果集中。如果表达式的值在列表或结果集中，则 `IN` 的结果为真，否则为假。在使用 `IN` 时，通常需要知道具体的值或子查询返回的值集合。

总的来说，`EXISTS` 通常用于检查子查询是否返回了行，而 `IN` 通常用于比较一个表达式是否在一个值列表或子查询的结果集中。

- 当子查询的表比较大时，使用"exists"关键字可以提高查询效率。"exists"关键字表示只需要判断外部查询的结果集中是否存在满足子查询条件的记录，而不需要获取子查询的具体结果集。因此，当子查询的表比较大时，使用"exists"可以有效减少总的循环次数，从而提升查询速度。
- 当外查询的表比较大时，使用"in"关键字可以提高查询效率。"in"关键字表示需要将外部查询的结果集和子查询的结果集进行比较，如果有相同的记录，则返回结果。由于"in"关键字需要对外查询表进行循环遍历，因此当外查询表比较大时，使用"in"可以有效减少循环遍历的次数，从而提升查询速度。

## 17 int(10)和char(10)区别

`int(10)`和`char(10)`是两种不同的数据类型，用于在MySQL中存储不同类型的数据。

`int(10)`是MySQL中的整数类型，其中括号中的数字10表示显示宽度。这并不影响该数据类型可以存储的最大值，而只是用于控制在显示结果时使用的位数。例如，如果一个数字只有3位，但其显示宽度为10，那么MySQL将在该数字前面添加7个空格以达到指定的显示宽度。

`char(10)`是MySQL中的字符串类型，其中括号中的数字10表示字符数限制。这意味着这个数据类型只能存储10个字符长度的字符串。如果尝试存储超过10个字符的字符串，MySQL将会截断这个字符串，只保存前10个字符。

`int(10)`的括号中的数字只是控制显示宽度，而`char(10)`的括号中的数字是字符数限制。

## 18 runcate、delete与drop区别？

- Truncate（截断）：用于删除数据库表中的所有数据，但保留表结构。它是一种快速清除表数据的方法，因为它不需要记录每个删除的行。但是，由于它不记录已删除的行，因此无法撤销或恢复已删除的数据。
- Delete（删除）：在数据库中，delete（删除）是用于删除表中的数据行的命令。它可以使用条件语句来指定要删除哪些数据行。删除操作会记录删除的行，因此可以通过回滚操作来恢复已删除的数据。
- Drop（删除）：在数据库中，Drop（删除）是用于删除整个表或其他数据库对象（如索引、触发器等）的命令。删除操作将删除表及其所有数据和约束，因此要谨慎使用。Drop命令不会记录已删除的对象，因此无法撤销或恢复已删除的表或对象。

一般来说，执行速度: drop > truncate > delete

## 19 having和where区别？

"Where"子句在查询语句中用于筛选行，它可以在选择行之前从数据表中排除一些行。通常使用WHERE子句来限制结果集中的记录，以仅显示满足特定条件的行。

Having"子句用于在已选择的结果集上进行过滤，通常与GROUP BY子句一起使用。HAVING子句类似于WHERE子句，但它是在GROUP BY分组后对分组结果进行筛选。

`where`子句作用于表和视图，`having`作用于组。

## 20 processList

MySQL的processlist是一个命令，用于显示MySQL服务器上正在运行的进程列表。这个列表包括了所有当前正在运行的查询，以及它们的状态、执行时间、以及正在等待的资源（如锁定、IO操作等）。在MySQL中，每个连接都被视为一个进程，因此这个列表中的每一行都对应一个连接。通过查看processlist，可以了解MySQL服务器上的活动情况，包括哪些查询正在运行，哪些查询占用了太多的资源等等。这对于监视服务器性能和排除故障非常有用。使用show processlist进行查看，尤其是要查没有慢`SQL`正在执行

## 21 limit 1000,10 和limit 10 速度不一样快

两种查询方式。对应 `limit offset, size` 和 `limit size` 两种方式。而其实 `limit size` ，相当于 `limit 0, size`。也就是从0开始取size条数据。

MySQL内部分为**server层**和**存储引擎层**。一般情况下存储引擎都用innodb。server层的执行器可以通过调用存储引擎提供的接口，将一行行数据取出，当这些数据完全符合要求（比如满足其他where条件），则会放到结果集中，最后返回给调用mysql的客户端。在执行语句的时候，server层会调用innodb的接口，对于1000,10，会在innodb里的主键索引中获取到第0到（1010）条行数据，返回给server层之后只留下最后10条数据，放到server层的结果集中，返回给客户端。所以当offset设置非0值的时候，server层会从引擎层获取到很多无用的数据，而获取的这些无用数据都是要耗时的。

因此，mysql查询中 limit 1000,10 会比 limit 10 更慢。原因是 limit 1000,10 会取出1000+10条数据，并抛弃前1000条，这部分耗时更大。

## 22 深分页怎么优化

还是以上面的SQL为空：`select * from xxx order by id limit 1000, 10;`

**方法一**：

而当select后面是*号时，就需要拷贝完整的行信息，拷贝完整数据比只拷贝行数据里的其中一两个列字段更耗费时间。所以先利用limit找一条1001的id

因为前面的offset条数据最后都是不要的，没有必要拷贝完整字段，所以可以将sql语句修改成：

```text
select * from xxx  where id >=(select id from xxx order by id limit 1000, 1) order by id limit 10;
```

先执行子查询 `select id from xxx by id limit 1000， 1`, 这个操作，这样只有id一个字段，拷贝的信息少，

```mysql
select * from xxx  where id >=1000 order by id limit 10;
```

这样innodb再走一次**主键索引**，通过B+树快速定位到id=1000的行数据，时间复杂度是lg(n)，然后向后取10条数据。

**方法二：**

将所有的数据**根据id主键进行排序**，然后分批次取，将当前批次的最大id作为下次筛选的条件进行查询。

```mysql
select * from xxx where id > start_id order by id limit 10;
```

通过主键索引，每次定位到start_id的位置，然后往后遍历10个数据，这样不管数据多大，查询性能都较为稳定。

## 23 高度为3的B+树可以存放多少数据

InnoDB存储引擎有自己的最小储存单元——页。

 innodb 默认的一页大小为 16384B = 16384/1024 = 16kb。

在MySQL中，B+树一个节点的大小设为一页或页的倍数最为合适。因为如果一个节点的大小 < 1页，那么读取这个节点的时候其实读取的还是一页，这样就造成了资源的浪费。

B+树中**非叶子节点存的是key + 指针**；**叶子节点存的是数据行**。

对于叶子节点，如果一行数据大小为1k，那么一页就能存16条数据。

对于非叶子节点，如果key使用的是bigint，则为8字节，指针在MySQL中为6字节，一共是14字节，则16k能存放 16 * 1024 / 14 = 1170 个索引指针。

于是可以算出，对于一颗高度为2的B+树，根节点存储索引指针节点，那么它有1170个叶子节点存储数据，每个叶子节点可以存储16条数据，一共 1170 x 16 = 18720 条数据。而对于高度为3的B+树，就可以存放 1170 x 1170 x 16 = 21902400 条数据（**两千多万条数据**），也就是对于两千多万条的数据，我们只需要**高度为3**的B+树就可以完成，通过主键查询只需要3次IO操作就能查到对应数据。

所以在 InnoDB 中B+树高度一般为3层时，就能满足千万级的数据存储。

## 24 count(1)、count(*)和count(字段名)区别

count(1) and count(字段名)的区别。

1. count(1)和count(*）差不多  会统计表中的所有的记录数，包含字段为null 的记录。
2. count(字段名) 会统计该字段在表中出现的次数，忽略字段为null 的情况。即不统计字段为null 的记录。

执行效果上：

- count(*)包括了所有的列，相当于行数，在统计结果的时候，**不会忽略列值为NULL**
- count(1)包括了忽略所有列，在统计结果的时候，**不会忽略列值为NULL**
- count(字段名)只包括列名那一列，在统计结果的时候，会忽略列值为null。

执行效率上：

- 列名为主键，count(列名)会比count(1)快
- 列名不为主键，count(1)会比count(列名)快
- 如果表多个列并且没有主键，则 count(1) 的执行效率优于 count(*)
- 如果有主键，则 select count(主键)的执行效率是最优的
- 如果表只有一个字段，则 select count(*)最优。

## 25 为什么不建议用外键

外键是关系数据库中的一种约束，它可以用来保证数据的完整性和一致性，具体来说，外键可以强制要求一个表中的某些列的值必须来自于另一个表中的某些列。下面是外键的一些好处和坏处：

好处：

1. 数据完整性：使用外键可以保证数据的完整性，因为它可以确保表中的数据符合参照完整性约束条件。也就是说，如果某些列的值必须来自于另一个表中的某些列，那么外键可以确保这个约束条件得到满足，从而保证数据的完整性。
2. 数据一致性：使用外键可以确保不同表中的数据一致。如果一个表中的数据被更新或删除，外键将确保在相关的表中也进行相应的更新或删除操作，从而确保数据一致性。
3. 查询性能：使用外键可以提高查询性能，因为外键可以帮助数据库优化查询计划，从而提高查询效率。

坏处：

1. 性能开销：使用外键可能会增加性能开销，特别是在大数据量、高并发的场景下。因为外键需要对表进行检查，这可能会降低插入、更新和删除操作的性能。
2. 维护复杂性：使用外键可能会增加维护的复杂性，因为外键需要关注多个表之间的关系。如果数据库设计不合理，可能会导致外键约束出现问题，从而影响数据的完整性和一致性。
3. 数据库设计复杂性：使用外键可能会增加数据库设计的复杂性，因为需要考虑多个表之间的关系。如果设计不当，可能会导致表之间的循环依赖关系，从而使外键约束无法生效。
4. 不利于分库分表。在水平拆分和分库的情况下，外键是无法生效的。将数据间关系的维护，放入应用程序中，为将来的分库分表省去很多的麻烦。

## 26 MySQL数据同步到Redis

**MySQL触发器+UDF函数**实现。

UDF函数是用户自定义函数，它可以在MySQL中被调用，用于处理用户自定义的数据类型或执行自定义的操作。

1. 在MySQL中对要操作的数据设置触发器Trigger，监听操作
2. 客户端向MySQL中写入数据时，触发器会被触发，触发之后调用MySQL的UDF函数
3. UDF函数可以把数据写入到Redis中进行同步

这种方案适合于读多写少，并且不存并发写的场景

使用MySQL binlog：通过解析MySQL binlog，得到所有对数据库的更改操作，并将它们同步到Redis缓存中。编写一个程序来监听MySQL binlog，并将更改操作转换为Redis命令进行同步。（通过canal实现。canal是阿里巴巴旗下的一款开源项目，基于数据库增量日志解析，提供增量数据订阅&消费）

## 27 禁止使用存储过程

存储过程是在大型数据库系统中，一组为了完成特定功能的SQL 语句集，它存储在数据库中，一次编译后永久有效，用户通过指定存储过程的名字并给出参数来执行它。

存储过程主要有以下几个缺点。

1. 可移植性：SQL 存储过程通常是针对特定的数据库引擎编写的。这意味着，如果需要将应用程序迁移到另一个数据库系统上，可能需要重新编写存储过程。这样做可能会导致额外的开销和风险。
2. 可维护性：由于 SQL 存储过程通常包含大量的业务逻辑和复杂的查询，它们可能会变得难以维护。而且，由于存储过程在数据库中运行，它们可能不易于版本控制和测试。
3. 性能：在某些情况下，使用存储过程可能会导致性能问题。例如，存储过程可能需要执行复杂的查询或使用不必要的锁定级别，从而导致性能下降。
4. 安全性：存储过程可以允许数据库管理员或其他用户在数据库中执行代码。这可能会带来安全风险，特别是在多租户环境中。
