[TOC]



## 0. 硬盘准备

需要先把内核代码写进磁盘中（项目中，我是直接把内核代码写入了二进制文件里，测试时使用Qemu启动）

## 1. 启动

### 1.1 boot

**BIOS 会自动识别将磁盘第一个扇区的内容，把这一段512b的内容加载到内存的特定地址（0x7c00）。这一段程序再加载loader引导程序。**

启动时，BIOS 会将磁盘的第1个扇区的内容，加载到内存的0x7c00处。（0x55 和 0xAA是引导记录的标记）CPU会跳转到此处执行指令。这段代码就是引导代码。由于引导代码不能超过个扇区的大小，因此还需要加载loader程序。这里使用了BIOS中断加载了磁盘后几个扇区的内容，也就是loader程序所在的位置。

最后，设置了栈指针，给内核作为函数调用的基础。指向0x7c00。

> 1. 按下开机键后，CPU 会强制将 pc 设置为 0xFFFF0。这是 BIOS 程序在内存中的映射地址（一跳）
> 2. 该入口地址处是一个跳转指令，跳转到 0xfe05b 位置，开始执行（二跳）
> 3. 执行了一些硬件检测工作后，最后一步将启动区内容加载到内存 0x7c00，并跳转到这里（三跳）
> 4. 启动区代码主要是加载操作系统内核，并跳转到加载处（四跳）



### 1.2 loader - (ELF、GDT)

**loader程序主要负责开启保护模式，加载内核代码，开启分页机制。**

loader 程序分为16位和32位。刚刚从硬盘中加载进来的loader程序是16位的，32位的程序要在保护模式下才能运行。因此，16位loader程序里，用BIOS中断检测了系统可用的内存。为了进入32位，需要

- 开启 A20 地址线
- 加载GDT表（目前只有一个段，不需要额外的设置）
- 写CR0寄存器的PE位，置为1。表示开启了保护模式。

然后跳转至32位的loader代码即可。

32位loader代码里，用LBA48模式，读取磁盘（开启保护模式后BIOS中断不能使用了），加载磁盘里的内核代码。这个内核代码实则是一个elf文件，把它读取到内存后，再按照elf文件的读取格式，在内存中解析它，加载到内存里相应的地址里。（64KiB处）



> ##### Extra 1 ELF文件
>
> elf文件里的关键字段有：
>
> - elf 文件开头的魔数
> - entry 可执行文件入口地址
> - phoff 程序段头表相对elf的偏移地址
> - phnum 程序段头表的条目数
>
> program header table 有：
>
> - type 该程序段的类型，比如可装载段，会被加载到内存
> - off 该程序段相对于elf文件起始的偏移地址
> - vaddr 该段加载到内存时的虚拟地址，exec函数
> - paddr 该段加载到内存时的物理地址，启动内核时加载elf文件用到
> - filesz 该段实际在磁盘中的大小
> - memsz 该段在内存中的大小 filesz ≤ memsz，因为bss
>
> 
>
> 加载完后，开启分页机制。在CR3寄存器里写页表地址，写CR0.PE位为1。目前是使用了一个4MiB的大页（设置CR4寄存器），来维持内核的正常运行。后续会使用多级页表管理内存。
>
> 最后，跳转至内核代码入口，即进入了内核程序，基本脱离了硬件级别的代码。
>
> 
>
> ##### Extra 2 GDT表
>
> **GDT表里存储了内存的分段信息。每个表项称为段描述符。段描述符记录了该段的地址、段大小、权限位等。**x86架构中，访问任何地址都需要遵循段地址+偏移，也就是段寄存器+IP寄存器。实模式下，可以通过段寄存器+偏移地址直接计算出实际访问的地址。在开启了保护模式后，段寄存器里储存的是段选择子，用于索引GDT表中的段描述符，因此，访问地址要经过GDT表来找到真正的段基址。
>
> 具体的标志位如下：
>
> • 段基址，被分散到了三个部分，平坦模式下一般就是 0 
>
> • 段界限与 G 位，段界限表示一个段的边界扩展最值，也就是表示一个段最大能有多大。G 表示单位， 0 表示 1B，1 表示 4KB。段界限这个数值和 G 这个单位两者一起才有意义，段界限共 20 位，故段 的最大值要么是 1M 要么是 4G。 
>
> • P 位，Present，表示该段是否在内存中，若在 P 为 1，反之为 0 
>
> • DPL，Descriptor Privilege Level，描述符特权级，0 最高，3 最低 
>
> • S 位，为 0 表示系统段，为 1 表示代码段或者数据段。
>
> • TYPE，段的类型，不同的段有不同的取值，比如标记它是系统调用门等。



## 2. 内核初始化

 ### 2.1 初始化GDT表

首先需要初始化GDT表，设置好数据段，代码段为固定值，使其不起作用（也就是0 + 权限位）。基地址为0，偏移量为整个32位内存空间。项目采用的是平坦模型，因此没有做有关分段的设置，所有的段统一为4G内存空间。对内存的管理，使用分页机制。

现代操作系统多采用平坦模型 + 分页机制来控制内存的读写。



### 2.2 初始化内核输出模块

这里主要是封装了outb指令，这个指令的作用是向特定的I/O端口发送数据。我参考手册，设置了一些串口通信的参数，使得可以直接把字符输出到屏幕。同时，封装好了printf来实现输出功能。

> printf的原理，概括来说，是涉及到变长参数的使用的问题。在调取参数时，会调用一个宏，让一个指针指向栈上的变参列表里第一个参数的地址。然后根据格式化字符串，扫描字符串中涉及到的变量的类型，然后解析。当要指向下一个参数时，根据变量类型来调整指针的位置。扫描格式化字符串时，每读取到一个变量，就推进一次指针，直到扫描字符串结束。



### 2.3 初始化内存管理

#### 2.3.1 内存分配器

**首先创建了一个内存分配器，使用了bitmap位图来管理物理内存。**它的功能是检视内存空间：

- 标记已经使用了的内存，bit位置为1。（可以在链接器中，读取内核代码的尾部，然后把0~内核代码尾部的标记全部置为1）
- 扫描未使用的内存，根据需要的大小，返回可以使用的内存空间的起始地址，然后置这段内存为1。

> 系统的内存布局
>
> 0x7c00以下：空。前期被拿来当栈使用
>
> 0x7c00~64KiB：前期加载内核时使用的内存空间
>
> 64KiB ~ 0x80000：内核代码
>
> 0x80000：显存

#### 2.3.2 虚拟内存和内核页表

**虚拟内存是什么？**虚拟内存是现代CPU管理内存访问内存的一种方式。在开启分页机制后，CPU访问的内存都是虚拟的，需要经过转换，才能得到真正的物理地址。现代操作系统中，这里通常使用页表来做转换。

**虚拟内存的作用：**

- 隔离地址空间，每个进程都可以用独立的地址空间，不会冲突
- 借助页表进行访问控制，进程之间不会相互干扰

**使用x86的二级页表机制来管理内存。创建了内核页表，做了整个内存空间的恒等映射，保证在内核空间中能够正常访问地址。**

其次是创建内核页表。内核页表也就是在内核中使用的页表，目的是为了能够在内核空间里做恒等映射，CPU访问内核代码时，不需要经过额外的地址转换。（用户进程是需要地址转换的，这涉及到地址空间隔离的问题）

对于一个用户进程来说，它的虚拟内存分布是这样的：0x80000000以下的区域是内核页表区，页表权限位U设置为了0，禁止用户态访问。8x80000000以上为用户页表，允许用户读写。

**页表管理方式**：

项目采用的是二级页表来管理虚拟内存。具体原理是，将一段虚拟地址，高10位作为页目录表（一级页表）的索引，从这个索引指向的页表项中，取出二级页表的地址，中间十位作为二级页表的索引，取出物理页的地址。然后通过虚拟地址的低12位寻址，定位最终访问的物理地址。

#### 2.3.3 GDT表相关的配置

项目里，针对GDT表设计了4个段：内核代码段，内核数据段，用户代码段，用户数据段。基址都是0，界限都是4G，唯一不同的区别在于访问权限DPL不一样。（内核段的DPL是0，意味着只有当前CPU权限级为0时，才能访问。）



### 2.4 初始化中断

中断的配置涉及到对8259芯片端口的写入。这里是参考手册写的，具体原理不太清楚。

首先需要配置好IDT表。根据x86手册，有20多个中断，依次写入IDT表中。触发中断时，根据中断号的下标，去访问中断向量表，取它的入口地址，访问中断处理程序。



### 2.5 初始化定时器

这一段也是通过对I/O端口配置定时器，具体原理不太了解，是参考手册做的。设置了大约10秒触发一次定时中断。



### 2.6 初始化进程配置，第一个进程

项目里使用了一个进程管理器和进程表来管理进程。

并创建了第一个用户进程，并加载进去执行。

由于目前还没有做文件系统，因此第一个进程的代码是和内核代码放置在一起的。但是它真正的执行地址，是在用户空间。项目中，我把用户空间的地址设为了0x80000000。在加载这第一个进程时，把这段进程的代码复制到了它自己的用户页表地址空间的0x80000000处。

进入第一个进程时，使用 iret 指令模拟从中断返回，来达到恢复进程的效果。具体是，在栈里压入了 ss, esp3, eflags, cs, ip 寄存器，使用 iret 返回。iret 的作用就是读取栈上面的这些寄存器。这样就相当于恢复到第一个进程的现场了。



## 3. 进程及其相关配置

### 3.1 进程结构及其初始化

在本项目中，一个进程具备以下结构：

- 当前的状态（就绪态、运行态、睡眠态、阻塞态、僵尸态）
- 进程的名字
- 进程pid
- 父进程指针
- 当前的时间片
- TSS结构
- TSS选择子（用于切换进程时访问）
- （完善之后，还会有和文件有关的内容，比如打开文件表等）

其中，TSS结构是x86CPU一个重要的结构。它起到了保存进程上下文的作用。

TSS 是一个结构体，里面保存了若干寄存器。在任务切换时，CPU会将当前寄存器保存在TSS结构里，然后读取下一个任务进程的TSS。重要的字段有：

- esp0内核栈指针
- esp3用户栈指针
- eip指令位置
- cr3页表寄存器
- cs寄存器（记录了运行时权限）
- eflags中断标志位等。

创建进程的代码步骤：

- 设置好进程的tss结构，即设置好入口地址，用户栈指针esp3
- 在GDT表中设置TSS门描述符，记录了该进程的TSS选择子和TSS结构的地址。
- 设置父进程是谁，进程的名字和pid等。
- 创建页表。
- 把进程设为就绪态，设置进程的时间片，加入进程队列。



### 3.2 进程调度

每当到了设定好的时钟间隔时，会触发时钟中断，跳转到IDT表里面的0x20号中断，并进入中断处理函数执行。函数会获取当前正在运行的进程，并让当前进程时间片-1。当时间片减为0时，把当前进程设置为阻塞态，放入进程队列队尾。然后选择队列中队头的进程，执行它。*如何执行，看下面*



### 3.3 进程切换

切换时，使用了x86的CPU指令ljmpl。该指令的操作数是tss选择子，其作用如下：

- 将当前寄存器保存在TSS结构里。TSS结构，在程序运行中，以选择子的方式储存在了TR寄存器里。
- 读取操作数中的TSS选择子，去GDT表中查询其TSS结构的地址，然后把下一个进程的上下文恢复至当前寄存器中。
- 把下一个进程的TSS选择子，储存到TR寄存器里。



### 3.4 锁

项目中实现了两种有关锁的机制，互斥锁与信号量。目前还没有真正地派上用场，相当于目前只是搭建好了基础设施。

#### 3.4.1 互斥锁

互斥锁是一个数据结构，里面有两个主要变量，一个是持有锁的进程，一个是阻塞队列。

进程给代码段上锁时，会修改锁的进程变量，指向自己。当另外一个进程要访问这段代码时，会判断锁是否被占用，如果被占用，则将自己加入锁的阻塞队列里。然后放弃当前的CPU时间片，进行进程调度。

当锁的持有者解锁时，会唤醒阻塞队列里面的一个进程，即将阻塞队列里的进程放入就绪队列里。

#### 3.4.2 信号量

信号量是一个数据结构，里面的主要变量是计数变量和阻塞队列。提供了两个函数，notify和wait。notify使得计数量+1，wait使得计数量-1。

当一个进程需要执行信号量控制的代码段时，需要调用wait。如果调用wait后计数小于0，则将自己放入阻塞队列中。直到有另一个进程，它使用了notify，会检测阻塞队列中是否有进程在等待。如果有，则将进程放入就绪队列中。如果没有，则将计数+1。

#### 3.4.3 什么时候使用？

目前来说，项目里主要是对公共资源，比如全局变量：读写进程表创建进程，使用内存分配器分配物理页时，都需要加锁。





## 4. 特权级切换

项目中的特权级切换，主要是内核态和用户态之间的切换。

用户态到内核态，低特权级到高特权级(ring3到ring0)，一般来说就是两种情况：一是系统调用，二是中断。

内核态到用户态，高特权级到低特权级(ring0到ring3)，相反，通常就是从系统调用或者中断中返回。中断使用 iret 指令返回（会返回eflags），系统调用使用 retf 返回（因为之前没有压入eflags）

特权级变化时的合法性检查，主要涉及到三个标志位：

- DPL：GDT表中的标志位，表示要访问这个段描述符，需要的特权级
- RPL：表示段描述符中指向的地址，运行它，会使用的特权级
- CPL：当前CS寄存器中的特权级标志位。表示当前CPU的特权级

> 使用 set_intr_gate 函数设置,传递给_set_gate 函数的 type 参数值为 DESCTYPE_INT。
>
> DESCTYPE_INT 表示中断门描述符,特权级为 0。因此,对于用户应用程序来说,因为 CPL 为 3,大于中断门的 DPL,所以不可能通过某种途径,比如调用一些汇编指令,穿过中断门去进入中断服务程序。
>
> 而对于中断来说,中断门的 DPL 被忽略,总是能通过。

> 通过中断切换特权级
> 当中断（硬件中断、软中断（INT指令）、异常）产生时，会保存SS|ESP|EFLAGS|CS|EIP|ErrorCode，SS和ESP 表示中断时堆栈信息，CS和EIP 表示中断处理完成后返回的地址，EFLAGS 表示中断时程序标志位（加减、溢出）。
>
> 特权级切换原理：
> 1）高特权级（level0）到低特权级（level3） ：直接将CS的CPL从0改成3、再将SS、ESP、EIP赋值为level3 的地址、再通过执行IRET指令完成切换。
>
> 2）低特权级到高特权级 ：在level3中使用软中断切换到level0,与此同时cpu会将level3中断的现场信息压入level0的栈,在中断返回前将栈中的CS的CPL从3改成0，且将其地址指向level0 要执行的下一个服务地址，去掉SS、ESP，通过执行IRET指令完成切换。

### 4.1 系统调用

首先，在GDT表中配置了调用门描述符。里面的关键字段如下：

- 需要把DPL设置为3，保证用户态代码能访问。
- 设置选择子为CS，其中RPL位为0，意味着系统调用的代码需要执行在特权级0的状态下。
- TYPE字段设置为SYSCALL，并在另一个字段设置了调用的参数为5个。

用户态程序调用时，先从用户态接口函数传入参数，把参数压栈后，使用lcall指令跳转至GDT表中的系统调用门。在这一过程中，CPU会进行特权级检查，**当前的CPL数值上要小于等于调用门的DPL，调用门的RPL数值上也需要小于等于DPL。**

并且，lcall指令的操作数如果是调用门，会把参数从用户栈复制进内核栈中。（根据调用门里的参数数量决定，并且与中断不同的是，不会自动压入EFLAGS寄存器）

调用门里储存了系统调用的分发函数，根据系统调用号，选择不同的分发函数，执行系统调用。（在这一步中，我压栈了尽可能多的寄存器，包裹成了一个结构体，读取到系统调用函数中使用。）

执行完毕后，返回值储存在 eax 中。使用 retf 指令（这个指令的作用是读取栈上的eip，cs后，可以跳过若干值。这里用作跳过了5个参数），返回即可。



### 4.2 中断

触发中断时，CPU会访问IDT表，根据中断向量号找到中断描述符后，将当前的CPL和目标段描述符的DPL进行对比。

如果数值上CPL > DPL，则说明要往高特权级转移，也意味着需要用内核栈。CPU会在TSS里取内核栈地址esp0，在内核栈保存当前的ss、esp3，然后保存eflags，cs，eip。

通过中断门访问中断服务程序时，CPU 会对 EFLAGS 的 IF 位清 0，即不允许其他中断打扰当前中断的执行，也就是中断的执行过程中关中断，再通过 iret 指令从中断返回时恢复 IF 位。而这里的恢复是指弹出栈中保存的 eflags 值到 EFLAGS 寄存器。

然后执行中断处理程序。

最后使用 iret 从中断中返回，会先读取 eflags，cs，eip。如果特权级需要切换（读取的cs和当前的cs权限位不一致），还会读取先前保存的ss，esp3，切换回用户栈。

摘抄：

> ***1.*** 如果发生了特权级转移，压入之前的堆栈段寄存器 SS 及栈顶指针 ESP 保存到栈中，并将堆栈切换为 TSS 中的堆栈。
>
> ***2.*** 压入标志寄存器 EFLAGS。
>
> ***3.*** 压入之前的代码段寄存器 CS 和指令寄存器 EIP，相当于压入返回地址。
>
> ***4.*** 如果此中断有错误码的，压入错误码 ERROR_CODE
>
> ***5.*** 结束（之后就跳转到中断程序了）

![图片](https://mmbiz.qpic.cn/mmbiz_png/GLeh42uInXRaebHKiaWevE73umedjHIDmah4woagFJsXMlXibia5XF5NdhblfaCFmlHbFlrVYUyMVDxVk7Ct88XSg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)



### 5. 系统调用

#### 1. sleep

sleep把当前进程设置为阻塞态，然后设置它的睡眠时间，放入睡眠队列里，然后调度下一个进程。每次触发时间中断时，会在睡眠队列中让进程的睡眠时间减一。当检测到某个进程睡眠时间为0时，将其唤醒，放到就绪队列中。



#### 2. fork

- 首先遍历任务结构体数组，寻找空闲的任务结构体，创建这个子进程。
- 将子进程的TSS：上下文寄存器设置的和父进程的上下文寄存器一致。
- 复制父进程的页表，让子进程建立一份相同的页表，并存入CR3寄存器中。
- 将子进程设置为就绪，加入准备队列。



#### 3. exec

exec，因为目前还没有做文件系统，所以目前只做好了这个接口，暂时可以读取内存中的程序。目前实现的效果是，可以加载内存中的elf文件。

- 创建一个新的页表空间，把elf文件装载进页表空间中。
- 分配新的用户栈空间，把栈设置在统一的位置（0xE0000000），并且把exec的参数拷贝到栈指针的位置。
  - **这里要特别注意，由于内存拷贝涉及到两个不同进程空间，传进来的参数可能会跨页表，因此需要额外处理，很复杂**
- 然后把内核栈里的进程上下文寄存器eax, ebx等清零，并设置esp指向新的栈顶，设置CR3指向新的页表。
- 销毁原页表地址空间的内存。
- 返回。此时调用ret返回后，就是新的进程环境了。

用户程序编译时，我设定了会和一个lib库、一个入口函数一起编译。lib库的作用就是提供系统调用的基本接口函数，入口函数的作用就是执行main（给main传入argc，argv），并接收main的返回值，调用exit退出进程。

> 在Cmake里设置了应用程序代码在编译时会和预先写好的一个lib库放在一起，lib库的代码是这段程序运行的首地址，这段代码调用main函数来执行相应的功能
>
> 操作系统在创建进程时，会将一段前置代码放入main前，这段代码需要初始化运行环境，初始化全局变量、堆、寄存器等，并将main的参数放入用户栈里。然后才会调用main函数，执行程序主体部分。执行完毕后，代码接收main的返回值，进行清理工作，全局变量析构，销毁堆，调用exit结束进程。



#### 4. printf 原理

printf是通过C语言的变参宏，把参数写入格式化字符串后，把字符串写入一个缓存数组里。把这个缓存的地址传入内核，在内核调用向串口输出的指令，实现把字符打印至屏幕上。

概括来说，是涉及到变长参数的使用的问题。在调取参数时，会调用一个宏，让一个指针指向栈上的变参列表里第一个参数的地址。然后根据格式化字符串，扫描字符串中涉及到的变量的类型，然后解析。当要指向下一个参数时，会使用一个宏，根据变量类型来调整指针的位置。扫描格式化字符串时，每读取到一个变量，就推进一次指针，直到扫描字符串结束。



#### 5. exit 和 wait

exit：将进程状态设为ZOMBIE，移出就绪队列，关闭打开的文件。

wait：遍历进程表，如果找到一个进程状态为ZOMBIE且父进程为自己，则清理资源，释放页表。否则把自己加入阻塞队列，重复上面的过程。