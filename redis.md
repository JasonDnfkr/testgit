[TOC]



### 1 Redis

Redis是一个基于 C 语言开发的开源数据库，Redis 的数据是存在内存中的（内存数据库），读写速度非常快，被广泛应用于缓存方向。并且，Redis 存储的是 KV 键值对数据。Redis 还支持事务 、持久化、Lua 脚本、多种开箱即用的集群方案

优缺点：内存读写速度快、数据结构丰富、支持事务、支持持久化，受到物理内存的限制，不能支持复杂查询

### 2 Redis 为什么这么快

内存存储：Redis 将所有数据都存储在内存中，这使得它可以非常快速地读取和写入数据，因为内存读写速度比磁盘要快得多。

单线程处理：Redis 是单线程应用程序，这意味着它不需要进行线程间切换和同步操作，从而减少了操作系统的开销和锁的争用。

I/O多路复用：它允许多个I/O操作同时在同一个线程中执行，不会阻塞任何一个请求，从而避免了线程切换的开销。当一个I/O操作完成时，Redis会立即将其结果返回给客户端。

数据结构优化：Redis 内置了多种数据结构（如哈希表、有序集合等），这些数据结构都经过了优化，可以在时间和空间上提供高效的性能。

#### I/O多路复用

`select`，`poll`和`epoll`都是在I/O多路复用中常用的系统调用。

它们的主要目的是让单个进程能够同时监视多个文件描述符（sockets、文件、标准输入输出等），并在它们之间进行切换，以便实现高效的异步I/O。

`select`和`poll`是较早的I/O多路复用机制，而`epoll`是Linux内核中引入的更高效的I/O多路复用机制。它们的区别在于实现机制和性能上的差异。

具体来说，`select`和`poll`都需要将要监视的文件描述符集合从用户空间拷贝到内核空间，这个开销在文件描述符数量较大时会变得很明显。而`epoll`使用基于事件驱动的方式来处理I/O事件，可以在内核空间中维护一个事件表，从而避免了拷贝开销。

因此，`epoll`通常比`select`和`poll`更高效，特别是在处理大量并发连接时，可以大幅降低系统开销。

在操作系统中，**文件描述符**（File Descriptor）是一个用于标识打开的文件或者 I/O 设备的整数值。文件描述符是操作系统内部为了管理文件和网络连接而创建的一个抽象概念，它在应用程序中被用来代表打开的文件、网络连接等 I/O 对象。

#### 为什么不用他做主数据库？

只能处理简单事务、数据存在内存、尽管有持久化、也会有限制，断点数据会丢失，数据结构还是比较简单，复杂的不好处理（表），没有安全机制，访问控制这种。

###  3 Redis 和 Memcached 的区别

相同点：

1. 内存缓存：Redis 和 Memcached 都是内存缓存系统，它们都将数据存储在内存中，因此读写速度非常快，适合于对速度要求较高的应用场景。
2. Key-Value 存储：Redis 和 Memcached 都是使用 Key-Value 存储方式，可以通过 key 来访问相应的 value。
3. 分布式架构：Redis 和 Memcached 都支持分布式架构，可以通过集群来扩展存储容量和性能。

不同点：

1. 数据类型：Redis 支持多种数据类型，如字符串、哈希表、列表、集合、有序集合等，而 Memcached 只支持简单的字符串类型。
2. 持久化支持：Redis 支持数据持久化，可以将数据存储到磁盘中，以防止数据丢失，而 Memcached 不支持数据持久化。
3. 数据处理能力：Redis 具备更强的数据处理能力，如支持事务、发布/订阅模式等功能，而 Memcached 只是一个简单的缓存系统，没有这些高级功能。
4. 内存管理：Redis 具备更灵活的内存管理能力，可以根据需要自动回收过期的数据和释放不必要的内存，而 Memcached 的内存管理比较简单，一般需要手动设置内存限制和过期时间。
5. redis单线程i/o多路复用，m用多线程的非阻塞io模型
6. 特别的是：Redis 提供主从同步机制和 cluster 集群部署能力，能够提供高可用服务。Memcached 没有提供原生的集群模式，需要依靠客户端实现往集群中分片写入数据。

### 4 为什么要用 Redis

**高性能**对经常要访问的数据减少对数据库的访问，直接从缓存中获取了，操作内存，所以速度相当快。

**高并发**一般像 MySQL 这类的数据库的 QPS 大概都在 1w 左右（4 核 8g） ，但是使用 Redis 缓存之后很容易达到 10w+，甚至最高能达到 30w+（就单机 Redis 的情况，Redis 集群的话会更高）。由此可见，直接操作缓存能够承受的数据库请求数量是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。进而，我们也就提高了系统整体的并发。

### 为什么要用 Redis 而不用 map/guava 做缓存?

使用自带的 map 或者 guava 实现的是**本地缓存**，最主要的特点是轻量以及快速，生命周期随着 jvm 的销毁而结束，并且在多实例的情况下，每个实例都需要各自保存一份缓存，缓存不具有一致性。

使用 redis 或 memcached 之类的称为**分布式缓存**，在多实例的情况下，各实例共用一份缓存数据，缓存具有一致性。

### 5 缓存读写策略

#### 1. 旁路缓存模式

写：先更新db，再删除redis 读：先从redis读，读到返回，读不到读db，返回，然后更新redis（应用读db）

不可以**先删再写**，因为A修改，删redis，B读：A先删，B读不到，从db中读，A修改db，B修改redis 导致不一致

**先改后删，**理论上也会出问题，但是概率很小，因为 A读没读到读db，B改db，A修改redis为原来的值，**因为缓存写入的速度比db写入的速度快很多，且一开始没缓存**

缺陷：首次读，肯定不在cache，所以先存热点数据

​			多次写的话，经常删除redis，命中率低，

​			缓存与数据库不一致，去改了，但是还没删除redis，读到的还是以前的

#### 2. 读写穿透

写：先查redis，没查到，就去更新db，查到就先更新redis，然后更新db

读：读redis，读到返回，读不到去读db，更新redis，后返回（redis读db和些redis）

#### 3. 异步缓存写入

redis读db和些redis，但他是异步去更新db，先更新了redis，之后异步批量更新db（数据经常变化、一致性不高的可以用，点赞这种）

### 6 redis应用

分布式锁、限流（redis + lua）、消息队列（list这个数据结构比较不错）、缓存热点数据

####  keys命令存在的问题

1. 性能问题：当Redis数据库中存在大量键值对时，使用"keys"命令可能会导致性能问题，因为Redis是单线程处理请求的，而"keys"命令需要在整个数据库中搜索匹配的键，这可能会导致阻塞其他请求。

2. 可能返回太多的键：使用"keys"命令时需要谨慎，因为它可能会返回太多的键，这可能会导致客户端内存溢出。如果需要获取大量键的值，可以考虑使用"SCAN"命令逐步获取匹配的键。

   每次scan命令的时间复杂度是`O(1)`，但是要真正实现keys的功能，需要执行多次scan。

   scan的缺点：在scan的过程中如果有键的变化（增加、删除、修改），遍历过程可能会出现会变化的键可能没有遍历到，遍历出了重复的键等情况

### 7 Redis数据类型

String（字符串）、List（列表）、Set（集合）、Hash（哈希）、Zset（有序集合）。

3 种特殊数据结构 ：HyperLogLogs（基数统计）、Bitmap （位存储）、Geospatial (地理位置)。

其底层实现主要依赖这 8 种数据结构：简单动态字符串（SDS）、LinkedList（双向链表）、Hash Table（哈希表）、SkipList（跳表）、Intset（整数集合）、ZipList（压缩列表）、QuickList（快速列表）。

**String**：SDS   **Lis**t：linkedlist和ziplist **hash**：ziplist和hashtable **set**：hashtable和intset  **zset**：ziplist skiplist

1 String 是一种二进制安全的数据结构，可以用来存储任何类型的数据比如字符串、整数、浮点数、图片（图片的路径）、序列化后的对象。

Redis 的 SDS （简单动态字符串）不光可以保存文本数据还可以保存二进制数据，并且获取字符串长度复杂度为 O(1),除此之外，Redis 的 SDS API 是安全的，不会造成缓冲区溢出。

应用场景：计数限流（incr、decr、get、set）、分布式锁（setnx）、常规数据（session、token、序列化对象、地址）

2 List 底层双向链表，可以在两端进行插入和删除  应用场景：最近联系人、消息队列

3 Hash   链表+ 数组  应用场景：一些信息，商品信息、用户信息

4 Set 无序集合、可以实现并集（SUNION key1 key2 ）、交集（SINTER key1 key2）、差集（SDIFF key1 key2）这种 应用场景：数据不重复的，共同好友、粉丝这种

5 Zset 有序集合，通过score进行排序 zadd key score member 适用场景：排行榜、步数排行。优先级任务队列 zrange(小到大) zrevrange(大到小) 这两个是 根据后面的范围  zrevrank（排序大到小）

###  8 String 还是 Hash 存储对象数据好

- String 存储的是序列化后的对象数据，存放的是整个对象。Hash 是对对象的每个字段单独存储，可以获取部分字段的信息，也可以修改或者添加部分字段，节省网络流量。如果对象中某些字段需要经常变动或者经常需要单独查询对象中的个别字段信息，Hash 就非常适合。
- String 存储相对来说更加节省内存，缓存相同数量的对象数据，String 消耗的内存约是 Hash 的一半。并且，存储具有多层嵌套的对象时也方便很多。如果系统对性能和资源消耗非常敏感的话，String 就非常适合。

**购物车信息String 、 Hash**   因此经常变化，所以用hash：**添加**，就是在这个key 增加 hash的key 和 value **查询** 对这个key的hash遍历，**改** hash的value **删除商品** 删除hash的key  **清空：**删除key

### 9 String 的底层实现

Redis 是基于 C 语言编写的，但是String并不是C中的字符串，因为C字符串\0结尾，自己写了SDS（简单动态字符串），SDS 共有五种实现方式 SDS_TYPE_5（并未用到）、SDS_TYPE_8、SDS_TYPE_16、SDS_TYPE_32、SDS_TYPE_64，其中只有后四种实际用到。Redis 会根据初始化的长度决定使用哪种类型，从而减少内存的使用。对于后四种实现都包含了下面这 4 个属性：**len** ：字符串的长度也就是已经使用的字节数**alloc**：总共可用的字符空间大小，**alloc-len** 就是 SDS 剩余的空间大小**buf[]**：实际存储字符串的数组**flags**：低三位保存这是什么类型的SDS

SDS 相比于 C 语言中的字符串有如下提升：

1. **可以避免缓冲区溢出** ：C 语言中的字符串被修改（比如拼接）时，一旦没有分配足够长度的内存空间，就会造成缓冲区溢出。SDS 被修改时，会先根据 len 属性检查空间大小是否满足要求，如果不满足，则先扩展至所需大小再进行修改操作。
2. **获取字符串长度的复杂度较低** ： C 语言中的字符串的长度通常是经过遍历计数来实现的，时间复杂度为 O(n)。SDS 的长度获取直接读取 len 属性即可，时间复杂度为 O(1)。
3. **二进制安全** ：C 语言中的字符串以空字符 `\0` 作为字符串结束的标识，这存在一些问题，像一些二进制文件（比如图片、视频、音频）就可能包括空字符，C 字符串无法正确保存。SDS 使用 len 属性判断字符串是否结束，不存在这个问题。

### 10 缓存和数据库数据一致性

在满足实时性的条件下，不存在两者完全保存一致的方案，只有最终一致性方案

①说一个比较差的方案，把数据库的所有值都存到cache，修改数据库的时候不更新缓存，但是会定期更新缓存（不一致，利用率低，不常用的还在redis中）

②解决利用率问题，只保留热点数据，所以写请求只写数据库，不改缓存，读请求先读redis，没有就去读数据库，然后写入缓存，且设置失效时间

③解决一致性问题，就要使得更新数据库的时候一起更新redis，所以有  先更新redis后更新数据库 或者先数据库后缓存 **这两个方案**（不考虑并发的话都可以）

​	考虑第一步成功，第二步失败，那么 方法1 就使得redis是新的，mysql是旧的，导致redis失效后，从mysql读的是旧的

​                     方法2 就是mysql对，redis旧，导致更新了之后发现还是不变，过一会才变

​	在并发的情况 AB都更新 先更新mysql 后他更新redis  则 A mysql B mysql B redis A redis

​											 先更新redis 后更新mysql     A redis Bredis Bmysql  A mysql   

  ④ 如果说对更新数据的时候就去更新redis 效率很低，有可能更新之后不用，所以要删除缓存

​			先删redis 后更新mysql  还是先更新mysql 后删redis  和前面讨论的一样只要第二步出错，结果就是错的		

⑤在并发的情况下， 删redis 更新db  a去更新 先把redis 删了 b去读 发现没有 在db中读，读到了旧，a去更新db，b返回修改redis 结果redis是旧的db是新的

​					              改db 删redis  出错情况 1 a去读没有redis  就去数据库读 2 b去改 把db改了 3删除redis 4 a返回修改redis

​	但是这种情况概率很低**1 没有redis**2 读写并发 **3 1和4的时间要比2+3的时间长**，因为2写db要加锁所以比读db要长很多，所以在并发下先改db再删redis是可行的

​			如果失败我们就需要**重试**！但是立即重试大概率失败、要重试多少次？且重试要一直占用资源 所以 解决方法 **异步重试**  

⑥ 所以把第二步（删redis）（或者重试这个操作）放到消息队列中，因为消息队列保证可靠性，成功消费之前不会消失，重启项目也不用担心，且保证投递的可靠性，成功消费才会删除，不用担心写队列失败或者维护成本，因为第二步失败和写队列同时失败概率很低，且项目基本都用到消息队列，没有新增很多成本

当然也可以不用写消息队列，使用订阅数据库变更日志再操作缓存，也就是说修改的时候，不删redis了，在数据库变更时，日志就就会变更，只要订阅了这个日志，根据这个日志的操作，删除对应的缓存

 ⑦  总结 写db，后删redis 配合消息队列或者订阅变更日志

 最后有个特殊的就是主从复制，a 改主 db 然后 删redis b读没有redis 从库读，此时从库还是旧值，写redis 从库更新 ， 所以需要延迟双删，就是在a删 更新之后 延迟一会再删

### 11 Redis线程模型

Redis的线程模型是单线程模型，采用了reactor模式，它使用事件驱动模型来实现高效的IO操作，使用一个事件循环来监听所有的socket事件，当有事件发生时，事件循环会通知文件事件处理器来处理这些事件。文件事件处理器使用IO多路复用技术，同时监听多个socket，当有事件发生时，会调用相应的回调函数来处理这些事件。

文件事件处理器主要是包含 4 个部分：多个 socket、IO 多路复用程序、文件事件分派器、事件处理器（主从连接处理器、连接应答处理器、命令请求处理器、命令回复处理器）

#### Redis6.0多线程

之前为什么不用多线程

单线程编程容易并且更容易维护；避免线程上下文切换和锁等开销，甚至会影响性能。影响Redis 的性能主要在内存和网络而不是CPU ；

**线程上下文切换**指的是当操作系统需要将正在执行的线程暂停下来并转而执行另一个线程时所进行的一系列操作，包括保存当前线程的上下文（即当前线程的状态、寄存器的值、堆栈指针等信息），然后恢复下一个要执行的线程的上下文，使其继续执行。

但是为什么又用了？**Redis6.0 引入多线程主要是为了提高网络 IO 读写性能**

虽然，Redis6.0 引入了多线程，但是 Redis 的多线程只是在网络数据的读写这类耗时操作上使用了，执行命令仍然是单线程顺序执行

### 12 Redis内存管理

#### Redis内存优化

1. 使用 Redis 的数据结构：Redis 提供了多种数据结构，如字符串、哈希表、列表、集合和有序集合等。在使用 Redis 时，需要根据实际情况选择最合适的数据结构，以减少内存的使用。
2. 使用 Redis 的压缩功能：Redis 支持压缩数据，压缩后的数据在存储时可以减少内存的使用。
3. 使用 Redis 的持久化功能：Redis 支持持久化数据到磁盘上，以防止内存不足的情况。可
4. 使用 Redis 的过期功能：Redis 支持设置过期时间，当数据过期时，Redis 会自动删除该数据。可以通过设置过期时间来减少不必要的数据占用内存。
5. 合理使用 Redis 的内存碎片整理功能：当 Redis 删除数据后，可能会留下一些内存碎片，导致内存浪费。Redis 提供了内存碎片整理功能，Redis 会在需要的时候对内存碎片进行整理，以减少内存的浪费。

#### 为什么过期时间

一般情况下，我们设置保存的缓存数据的时候都会设置一个过期时间。为什么呢？ expire

因为内存是有限的，如果缓存中的所有数据都是一直保存的话，分分钟直接 Out of memory。很多时候，我们的业务场景就是需要某个数据只在某一时间段内存在，比如我们的短信验证码可能只在 1 分钟内有效，用户登录的 token 可能只在 1 天内有效。如果使用传统的数据库来处理的话，一般都是自己判断过期，这样更麻烦并且性能要差很多。

Redis 中除了字符串类型有自己独有设置过期时间的命令 `setex` 外，其他方法都需要依靠 `expire` 命令来设置过期时间 。另外， `persist` 命令可以移除一个键的过期时间。

#### 如何判断数据是否过期

Redis 通过一个叫做过期hash 表来保存数据过期的时间。过期hash 表的键指向 Redis 数据库中的某个 key(键)，过期字典的值是一个 long long 类型的整数，这个整数保存了 key 所指向的数据库键的过期时间（毫秒精度的 UNIX 时间戳）。

#### 过期的数据的删除策略

如果假设你设置了一批 key 只能存活 1 分钟，那么 1 分钟后，Redis 是怎么对这批 key 进行删除的呢？

1. **惰性删除** ：只会在取出 key 的时候才对数据进行过期检查。这样对 CPU 最友好，但是可能会造成太多过期 key 没有被删除。
2. **定期删除** ： 每隔一段时间抽取一批 key 执行删除过期 key 操作。

定期删除对内存更加友好，惰性删除对 CPU 更加友好（因为Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响）。所以 Redis 采用的是 **定期删除+惰性删除** 。

但是，仅仅通过给 key 设置过期时间还是有问题的。因为还是可能存在定期删除和惰性删除漏掉了很多过期 key 的情况。这样就导致大量过期 key 堆积在内存里，然后就 Out of memory 了。怎么解决这个问题呢？答案就是：**Redis 内存淘汰机制。**

#### Redis过期了内存没释放

还有可能没有进行惰性删除和定期删除，也有可能没过期也会被释放（内存淘汰机制）

#### Redis 内存淘汰机制

相关问题：MySQL 里有 2000w 数据，Redis 中只存 20w 的数据，如何保证 Redis 中的数据都是热点数据?

Redis 提供 6 种数据淘汰策略：当内存不足以容纳新写入数据时，新写入操作会报错。从所有key中挑选最近最少使用的进行淘汰。从设置了过期时间的key中挑选最近最少使用的进行淘汰。从所有key中随机选择进行淘汰。从设置了过期时间的key中随机选择进行淘汰。从设置了过期时间的key中，根据过期时间进行淘汰，越早过期的越优先淘汰。

### 13 Redis 性能优化

####  使用批量操作减少网络传输

一个 Redis 命令的执行可以简化为以下 4 步：

1发送命令 2命令排队3命令执行4返回结果

其中，第 1 步和第 4 步耗费时间之和称为 **Round Trip Time (RTT,往返时间)** ，也就是数据在网络上传输的时间。

**使用批量操作可以减少网络传输次数，进而有效减小网络开销，大幅减少 RTT。**

Redis 中有一些原生支持批量操作的命令，比如：

- `mget`(获取一个或多个指定 key 的值)、`mset`(设置一个或多个指定 key 的值)、
- `hmget`(获取指定哈希表中一个或者多个指定字段的值)、`hmset`(同时将一个或多个 field-value 对设置到指定哈希表中)、
- `sadd`（向指定集合添加一个或多个元素）

#### pipeline流水线

对于不支持批量操作的命令，我们可以利用 **pipeline（流水线)** 将一批 Redis 命令封装成一组，这些 Redis 命令会被一次性提交到 Redis 服务器，只需要一次网络传输。不过，需要注意控制一次批量操作的 **元素个数**(例如 500 以内，实际也和元素字节数有关)，避免网络传输的数据量过大。

与`mget`、`mset`等原生批量操作命令一样，pipeline 同样在 Redis Cluster 上使用会存在一些小问题。原因类似，无法保证所有的 key 都在同一个 **hash slot**（哈希槽）上。如果想要使用的话，客户端需要自己维护 key 与 slot 的关系。

原生批量操作命令(mset和mge)和 pipeline 的是有区别的，使用的时候需要注意：

- 原生批量操作命令是原子操作，pipeline 是非原子操作；
- pipeline 可以打包不同的命令，原生批量操作命令不可以；
- 原生批量操作命令是 Redis 服务端支持实现的，而 pipeline 需要服务端和客户端的共同实现。

另外，pipeline 不适用于执行顺序有依赖关系的一批命令。就比如说，你需要将前一个命令的结果给后续的命令使用，pipeline 就没办法满足你的需求了。对于这种需求，我们可以使用 **Lua 脚本** 。

#### Lua 脚本

Lua 脚本同样支持批量操作多条命令。一段 Lua 脚本可以视作一条命令执行，可以看作是原子操作。一段 Lua 脚本执行过程中不会有其他脚本或 Redis 命令同时执行，保证了操作不会被其他指令插入或打扰，并且Lua 脚本中支持一些简单的逻辑处理比如使用命令读取值并在 Lua 脚本中进行处理，这同样是 pipeline 所不具备的。不过， Redis Cluster 下 Lua 脚本的原子操作也无法保证了，原因同样是无法保证所有的 key 都在同一个 **hash slot**（哈希槽）上。

#### 大量 key 集中过期问题

我在前面提到过：对于过期 key，Redis 采用的是 **定期删除+惰性删除** 策略。

定期删除执行过程中，如果突然遇到大量过期 key 的话，客户端请求必须等待定期清理过期 key 任务线程执行完成，因为这个这个定期任务线程是在 Redis 主线程中执行的。这就导致客户端请求没办法被及时处理，响应速度会比较慢。

1. 给 key 设置合理的过期时间（比如随机时间）。
2. 开启 lazy-free（惰性删除/延迟释放） 。lazy-free 特性是 Redis 4.0 开始引入的，指的是让 Redis 采用异步方式延迟释放 key 使用的内存，将该操作交给单独的子线程处理，避免阻塞主线程。
3. 使用Redis集群来分散过期Key的删除负载，可以将Key均匀地分布在多个节点上，避免单个节点过度负载。
4. 对于需要大量过期的Key，可以采用Redis的zset来存储，将过期时间作为Score，利用Redis提供的zremrangebyscore命令一次性删除过期的Key

#### Redis bigkey

**什么是 bigkey？简**单来说，如果一个 key 对应的 value 所占用的内存比较大，那这个 key 就可以看作是 bigkey。具体多大才算大呢？有一个不是特别精确的参考标准：string 类型的 value 超过 10 kb，复合类型的 value 包含的元素超过 5000 个.

**bigkey 有什么危害？**除了会消耗更多的内存空间，bigkey 对性能也会有比较大的影响。

如何发现 bigkey: ①使用 Redis 自带的 `--bigkeys` 参数来查找 //redis-cli -p 6379 --bigkeys

这个命令会扫描(Scan) Redis 中的所有 key ，会对 Redis 的性能有一点影响。并且，这种方式只能找出每种数据结构 top 1 bigkey

②分析 RDB 文件：通过分析 RDB 文件来找出 big key。这种方案的前提是你的 Redis 采用的是 RDB 持久化。

#### Redis 内存碎片

什么是内存碎片?内存中未被使用的小块内存，

**为什么会有内存碎片**：由于Redis采用了自己的内存分配器，而内存分配器在分配内存时可能会分配比请求的更多的内存，因此当Redis处理大量小的写入请求时，会在内存中留下许多未被使用的小块内存，还有就是某个数据删除时，一般不会轻易释放内存给操作系统，

**如何清理 Redis 内存碎片？**

```bash
config set activedefrag yes
```

为了避免内存碎片问题，可以采取以下措施：

1. 使用Redis的内存清理命令，例如"MEMORY PURGE"或"MEMORY DOCTOR"，来回收未使用的内存。
2. 在Redis中设置合适的最大内存限制，避免Redis占用过多的内存。
3. 在Redis中的RDB或AOF持久化机制，在重启时可以重新分配整个内存。
4. 避免使用过多的短连接和短期数据，这可能会导致内存碎片的产生。

### 14 redis变慢什么原因

使用的内存达到上限，因为要进行淘汰策略 解决：随机淘汰块

使用了swap，操作系统为了缓解内存不足对应用程序的影响，允许把一部分内存中的数据换到磁盘上，以达到应用程序对内存使用的缓冲，这些内存数据被换到磁盘上的区域，就是 Swap。当内存中的数据被换到磁盘上后，Redis 再访问这些数据时，就需要从磁盘上读取，访问磁盘的速度要比访问内存慢几百倍，解决方法：增加内存，释放内存等，宾冕swap

存在bigkey，这种淘汰删除会很久，尽量避免

网络带宽原因，可能过载了

频繁的短连接：会导致资源小孩在建立连接和释放

### 15 Redis 持久化机制

Redis 支持持久化，而且支持两种不同的持久化操作。Redis 的一种持久化方式叫快照（默认）（RDB），另一种方式是只追加文件（AOF）。

####  RDB

RDB将Redis数据库的数据保存在磁盘上，以便在Redis服务器重启时重新加载数据。在RDB持久化中，Redis会将数据库快照保存到一个文件中。该文件包含Redis当前状态下的所有数据，包括键和与之关联的值。这个文件可以在服务器重启时重新加载，以便Redis可以恢复之前保存的状态。

**执行过程：**

先执行`BGSAVE`命令

Redis 父进程判断当前有没有子进程在进行，如果有，`BGSAVE`命令直接返回。

父进程执行`fork`操作**创建子进程**，fork操作的过程中会阻塞父进程。

父进程`fork`完成后，父进程就继续处理客户端的请求，而fork出来的子进程开始将内存中的数据写进磁盘文件；

当子进程写完所有数据后会用该文件替换原来的 RDB 文件。

**触发方式**：手动触发（save或者bgsave命令） 被动触发（配置规则 save 10 5 在 10s内至少5个键被修改就快照，shutdown的时候也会自动执行bgsave（不开启aof的前提下））

#### RDB 创建快照时会阻塞主线程？

Redis 提供了两个命令来生成 RDB 快照文件：

- `save` : 同步保存操作，会阻塞 Redis 主线程；
- `bgsave` : fork 出一个子进程，子进程执行，不会阻塞 Redis主线程，默认选项。

#### AOF 

它通过将 Redis 执行的所有写操作追加到一个文件的末尾，来记录 Redis 数据库的每个修改操作。当 Redis 重新启动时，它会通过重新执行 AOF 文件中的所有命令，将数据库状态恢复到重新启动之前的状态。这种方式可以保证数据在断电等异常情况下不会丢失

**AOF 持久化有两种方式**：每个写命令都立即写入磁盘和每秒钟同步一次磁盘。第一种方式可以提供更好的数据保护，但是会导致更慢的写入性能，因为需要频繁地写入磁盘。第二种方式会提供更好的写入性能，但是可能会导致在异常情况下丢失一秒钟的数据。

为了兼顾数据和写入性能，用户可以考虑 每秒钟同步一次磁盘，让 Redis 每秒同步一次 AOF 文件，Redis 性能几乎没受到任何影响。而且这样即使出现系统崩溃，用户最多只会丢失一秒之内产生的数据。

**执行过程**：

所有的写入命令会追加到 AOF 缓冲区中。

AOF 缓冲区根据对应的策略向硬盘同步。

当 AOF 文件大到一定程度时，需要定期对 AOF 文件进行重写，压缩文件体积

#### AOF 日志实现

 Redis AOF 持久化机制是在执行完命令之后再记录日志。myql通常都是执行命令之前记录日志（方便故障恢复）

- 避免额外的检查开销，AOF 记录日志不会对命令进行语法检查；
- 在命令执行完之后再记录，不会阻塞当前的命令执行。

这样也带来了风险

- 如果刚执行完命令 Redis 就宕机会导致对应的修改丢失；
- 可能会阻塞后续其他命令的执行（AOF 记录日志是在 Redis 主线程中进行的）。

#### AOF 重写

AOF 重写是 Redis 中一种用于优化 AOF 文件大小的机制。由于 AOF 文件会不断增长，文件过大会带来磁盘空间的浪费和 Redis 重启时恢复数据的延迟。因此，Redis 引入了 AOF 重写机制，用于定期地对 AOF 文件进行压缩。

AOF 重写的基本原理是通过遍历数据库中的所有键值对，来重写一个新的 AOF 文件。重写的过程中，Redis 会将相同操作的指令合并，并且删除一些被覆盖的旧指令，以达到压缩文件大小的效果，同时Redis 会维护一个 AOF 重写缓冲区，该缓冲区会在子进程创建新 AOF 文件期间，记录服务器执行的所有写命令，当重写完成后，把这个缓冲区的内容添加到新的aof文件后，最后服务器用新的 AOF 文件替换旧的 AOF 文件

AOF 重写可以通过两种方式触发：一种是定期触发，可以在 Redis 配置文件中设置重写的周期；另一种是基于 AOF 文件大小的动态触发，当 AOF 文件大小超过指定大小时，Redis 会自动触发重写。

#### 如何选择

**RDB 优点** ：

- 文件比AOF文件更小，因为RDB是一个压缩过的二进制文件，而AOF是一个文本文件。
- 恢复速度比AOF快，因为RDB文件只需要简单地加载到内存中，而AOF文件需要重放所有操作，这可能需要一些时间。
- RDB可以定期进行自动备份，并且生成的备份文件可以用于复制和迁移。
- RDB文件对于长期存储是可靠的，因为它们不容易损坏，而且对于需要对数据完整性有很高要求的应用程序是非常适合的。

**RDB缺点**：

1. RDB是定期保存，没有做到实时持久化、可能会丢失一些最近的数据更改。
2. RDB文件的恢复点可能不如AOF文件精确，因为最后一次保存的数据可能会被丢失。

**AOF优点**：

1. 数据更完整，最多丢失1s
2. AOF文件记录了每个写入Redis的操作，这意味着可以通过查看AOF文件来了解Redis数据库的历史操作。

**AOF缺点**：

1. AOF文件可能比RDB文件大，因为它是一个文本文件，记录了每个操作。
2. AOF文件可能比RDB文件恢复速度慢，因为需要重放所有操作。

因此，当需要对Redis数据进行备份或灾难恢复时，可以选择RDB方式；当需要最大程度地避免数据丢失或需要在Redis重启时尽可能准确地恢复数据时，可以选择AOF方式。也可以将两种持久化方式结合起来使用，以提高数据的安全性和恢复能力。

通常来说，应该同时使用两种持久化方案，以保证数据安全。

- 如果数据比较重要，且能够承受几分钟的数据丢失，比如缓存等，只需要使用RDB即可。
- 如果要求更加完整的数据，AOF

当RDB与AOF两种方式都开启时，Redis会优先使用AOF恢复数据，因为AOF保存的文件比RDB文件更完整。

####  Redis 4.0 对于持久化优化

由于 RDB 和 AOF 各有优势，于是，Redis 4.0 开始支持 RDB 和 AOF 的混合持久化（默认关闭）

如果把混合持久化打开，AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头。这样做的好处是可以结合 RDB 和 AOF 的优点, 快速加载同时避免丢失过多的数据。当然缺点也是有的， AOF 里面的 RDB 部分是压缩格式不再是 AOF 格式，可读性较差。

### 16 Redis事务

#### 如何使用 Redis 事务？

Redis 可以通过 **`MULTI`，`EXEC`，`DISCARD` 和 `WATCH`** 等命令来实现事务功能。

multi开启事务，exec结束事务，并执行事务中的命令， discard取消事务，前面的命令不执行  **watch** 监听指定的 Key，当调用 `EXEC` 命令执行事务时，如果一个被 `WATCH` 命令监视的 Key 被 其他客户端 修改的话，自己这个客户端操作了这个key的话，这个事务就不会被执行。，本客户端事务外部操作也是可以的

#### Redis事务支持隔离性

为了确保 Redis 事务的隔离性，可以使用 MULTI、EXEC 和 DISCARD 命令，将需要在一个事务中执行的操作封装在一个原子性的操作序列中。如果需要更高的隔离级别，可以使用 Redis 的 WATCH 命令监视一个或多个键，并在事务执行期间检查这些键是否已被修改。如果被修改了，则事务将回滚。这样可以确保事务在执行期间不会受到其他客户端的干扰。

#### Redis 事务不支持原子性

Redis单条命令是原子性执行的，Redis 事务在运行错误的情况下，除了执行过程中出现错误的命令外，其他命令都能正常执行。并且，Redis 事务是不支持回滚（roll back）操作的。因此，Redis 事务其实是不满足原子性的（而且不满足持久性）。

Redis 官网也解释了自己为啥不支持回滚。简单来说就是 Redis 开发者们觉得没必要支持回滚，这样更简单便捷并且性能更好。Redis 开发者觉得即使命令执行错误也应该在开发过程中就被发现而不是生产过程中。

你可以将 Redis 中的事务就理解为 ：**Redis 事务提供了一种将多个命令请求打包的功能。然后，再按顺序执行打包的所有命令，并且不会被中途打断。**

除了不满足原子性之外，事务中的每条命令都会与 Redis 服务器进行网络交互，**这是比较浪费资源的行为**。明明一次批量执行多个命令就可以了，这种操作实在是看不懂。因此，Redis 事务是不建议在日常开发中使用的。

#### 如何解决 Redis 事务的缺陷？

可以利用 Lua 脚本来批量执行多条 Redis 命令，这些 Redis 命令会被提交到 Redis 服务器一次性执行完成，大幅减小了网络开销。

一段 Lua 脚本可以视作一条命令执行，一段 Lua 脚本执行过程中不会有其他脚本或 Redis 命令同时执行，保证了操作不会被其他指令插入或打扰。

不过，如果 Lua 脚本运行时出错并中途结束，**出错之后的命令是不会被执行的。并且，出错之前执行的命令是无法被撤销的**，无法实现类似关系型数据库执行失败可以回滚的那种原子性效果。因此， **严格来说的话，通过 Lua 脚本来批量执行 Redis 命令实际也是不完全满足原子性的。**

如果想要让 Lua 脚本中的命令全部执行，必须保证语句语法和命令都是对的。

### 17 Redis 生产问题

#### 缓存穿透

缓存穿透说简单点就是大量请求的 key 是不合理的，**根本不存在于缓存中，也不存在于数据库中** 。这就导致这些请求直接到了数据库上，根本没有经过缓存这一层，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了。

解决办法：

( 1）**对空值缓存**∶如果一个查询返回的数据为空(不管是数据是否不存在），我们仍然把这个空结果( null ）进行缓存，设置空结果的过期时间会很短，最长不超过五分钟;
(2)**设置可访问的名单(白名单**):使用bitmaps类型定义一个可以访问的名单，名单id作为 bitmaps的偏移量每次访问和 bitmap 里面的id进行比较，如果访问id不在bitmaps 里面，进行拦截，不允许访问。
(3）**采用布隆过滤器**∶使用布隆过滤器存储**所有可能访问的 key**，不存在的 key 直接被过滤，存在的 key 则再进一步查询缓存和数据库。它实际上是一个很长的二进制向量(位图)和一系列随机映射函数（哈希函数 ，k个hash函数映射，生成k的hash值，放到过滤器中，如果要查找的key对7个hash后，有一个不存在，就不存在)。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难)将所有可能存在的数据哈希到一个足够大的bitmaps 中，一个一定不存在的数据会被这个 bitmaps 拦截掉，从而避免了对底层存储系统的查询压力。

(4)**进行实时监控**:当发现 Redis 的命中率开始急速降低，需要排查访问对象和访问的数据，和运维人员配合，可以设置黑名单限制服务

(5**)接口校验**：在正常业务流程中可能会存在少量访问不存在 key 的情况，但是一般不会出现大量的情况，所以这种场景最大的可能性是遭受了非法攻击。可以在最外层先做一层校验：用户鉴权、数据合法性校验等，例如商品查询中，商品的ID是正整数，则可以直接对非正整数直接过滤等等。

#### 缓存击穿

缓存击穿中，请求的 key 对应的是 **热点数据** ，该数据 **存在于数据库中，但不存在于缓存中（通常是因为缓存中的那份数据已经过期）** 。这就可能会导致瞬时大量的请求直接打到了数据库上，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了

解决办法：

(1）**预先设置热门数据**:在redis高峰访问之前，把一些热门数据提前存入到redis里面，加大这些热门数据key的时长
(2)**实时调整**:现场监控哪些数据热门，实时调整key的过期时长

请求数据库写数据到缓存之前，先获取互斥锁，保证只有一个请求会落到数据库上，减少数据库的压力。

#### 缓存雪崩

**缓存在同一时间大面积的失效，导致大量的请求都直接落到了数据库上，对数据库造成了巨大的压力。** 这就好比雪崩一样，摧枯拉朽之势，数据库的压力可想而知，可能直接就被这么多请求弄宕机了。另外，缓存服务宕机也会导致缓存雪崩现象，导致所有的请求都落到了数据库上。

解决办法：

**针对 Redis 服务不可用的情况：**

1. 采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用。
2. 限流，避免同时处理大量的请求。

**针对热点缓存失效的情况：**

1. 设置不同的失效时间比如随机设置缓存的失效时间。
2. 将缓存失效时间分散开
3. 设置二级缓存:nginx缓存+ redis缓存+其他缓存( ehcache等) ,

### 18 Redis部署方案

1. 单机部署：最简单的方式是在一台服务器上部署Redis，适用于小规模的应用场景。
2. 主从复制部署：可以将一台Redis服务器作为主服务器，多台Redis服务器作为从服务器，主服务器将写操作同步给从服务器，实现数据的备份和读写分离，提高性能和可靠性。
3. 哨兵部署：适用于高可用性场景，可以在主从复制的基础上，引入Redis Sentinel来监控主服务器的状态，一旦主服务器宕机，哨兵会自动将从服务器选举为新的主服务器，保证系统的可用性。
4. 集群部署：可以将多个Redis实例组成一个集群，每个实例负责一部分数据，提高数据处理能力和可用性。
5. 分片部署：适用于数据量较大的场景，可以将数据分片存储在多个Redis服务器中，每个Redis服务器负责一部分数据，提高数据处理能力和可用性。

**主从复制的原理？**

1. 当启动一个从节点时，它会发送一个 `PSYNC` 命令给主节点；
2. 如果是从节点初次连接到主节点，那么会触发一次全量复制。此时主节点会启动一个后台线程，开始生成一份 `RDB` 快照文件；
3. 同时还会将从客户端 client 新收到的所有写命令缓存在内存中。`RDB` 文件生成完毕后， 主节点会将`RDB`文件发送给从节点，从节点会先将`RDB`文件**写入本地磁盘，然后再从本地磁盘加载到内存中**；
4. 接着主节点会将内存中缓存的写命令发送到从节点，从节点同步这些数据；
5. 如果从节点跟主节点之间网络出现故障，连接断开了，会自动重连，连接之后主节点仅会将部分缺失的数据同步给从节点。

主从复制存在不能自动故障转移、达不到高可用的问题。哨兵模式解决了这些问题。通过哨兵机制可以自动切换主从节点

**哨兵工作原理：**

每个`Sentinel`以每秒钟一次的频率向它所知道的`Master`，`Slave`以及其他 `Sentinel `实例发送一个 `PING`命令。

如果一个实例距离最后一次有效回复 `PING` 命令的时间超过指定值， 则这个实例会被 `Sentine` 标记为主观下线。

如果一个`Master`被标记为主观下线，则正在监视这个`Master`的所有 `Sentinel `要以每秒一次的频率确认`Master`是否真正进入主观下线状态。

当有足够数量的 `Sentinel`（大于等于配置文件指定值）在指定的时间范围内确认`Master`的确进入了主观下线状态， 则`Master`会被标记为客观下线 。若没有足够数量的 `Sentinel `同意 `Master` 已经下线， `Master` 的客观下线状态就会被解除。 若 `Master`重新向 `Sentinel` 的 `PING` 命令返回有效回复， `Master` 的主观下线状态就会被移除。

哨兵节点会选举出哨兵 leader，负责故障转移的工作。

哨兵 leader 会推选出某个表现良好的从节点成为新的主节点，然后通知其他从节点更新主节点信息。



哨兵模式解决了主从复制不能自动故障转移、达不到高可用的问题，但还是存在主节点的写能力、容量受限于单机配置的问题。而cluster模式实现了Redis的分布式存储，每个节点存储不同的内容，解决主节点的写能力、容量受限于单机配置的问题。

Redis cluster集群节点最小配置6个节点以上（3主3从），其中主节点提供读写操作，从节点作为备用节点，不提供请求，只作为故障转移使用。

**工作原理：**

1. 通过哈希的方式，将数据分片，每个节点均分存储一定哈希槽(哈希值)区间的数据，默认分配了16384 个槽位
2. 每份数据分片会存储在多个互为主从的多节点上
3. 数据写入先写主节点，再同步到从节点(支持配置为阻塞同步)
4. 同一分片多个节点间的数据不保持一致性
5. 读取数据时，当客户端操作的key没有分配在该节点上时，redis会返回转向指令，指向正确的节点
6. 扩容时时需要需要把旧节点的数据迁移一部分到新节点

### 19 Redis 哨兵

#### 什么是 Sentinel（哨兵）

Redis Sentinel 是 Redis 的高可用性解决方案之一，它是一个分布式系统，用于监控 Redis 主从复制集群中的节点，以确保系统的可用性和可靠性。

在 Redis 主从复制集群中，主节点负责接收写入操作并将数据同步到从节点，从节点则负责处理读取请求。如果主节点发生故障，Redis Sentinel 可以自动地将从节点提升为主节点，以保证数据的可用性和一致性。同时，Redis Sentinel 还可以监控节点的健康状态，以及自动地发现和添加新节点。

Redis Sentinel 的主要用途是确保 Redis 集群的高可用性，避免单点故障导致系统不可用，从而提高系统的可靠性和稳定性。

#### Sentinel 检测节点下线

主观下线是指 Sentinel 在规定时间内未能与节点保持正常通信，因此 Sentinel 认为该节点已经下线。Sentinel 会将节点标记为主观下线，并向其他 Sentinel 发布该信息，让其他 Sentinel 进行确认。

客观下线是指 Sentinel 在与其他 Sentinel 进行确认后，多数 Sentinel 认为该节点已经下线。在这种情况下，Sentinel 会将节点标记为客观下线，并向其他 Sentinel 发布该信息，让其他 Sentinel 进行确认。

在 Redis Sentinel 中，每个 Sentinel 会向其他 Sentinel 定期发送 ping 请求，如果一个 Sentinel 在规定时间内未能收到另一个 Sentinel 的响应，则认为对方 Sentinel 已经下线。当多数 Sentinel 都认为某个节点已经下线时，Sentinel 会将该节点标记为客观下线，并启动故障转移流程。

除了 Sentinel 之间的通信外，Sentinel 还会监控 Redis 实例的运行状态。当 Redis 实例在规定时间内未能响应 Sentinel 的请求时，Sentinel 会将该节点标记为主观下线。如果 Sentinel 持续一段时间无法与 Redis 实例通信，就会将该节点标记为客观下线，并启动故障转移流程。

#### Sentinel 故障转移

在 Redis 主节点不可用时自动执行故障转移来确保 Redis 的高可用性。

1. Sentinel 通过向 Redis 主节点发送命令来检测主从节点的状态，包括心跳检测、状态检测等。
2. 如果 Sentinel 发现主节点不可用，它会选择一个合适的从节点作为新的主节点。选择过程会考虑节点的优先级、复制偏移量、已经选中的从节点数等因素，从而保证新的主节点是最合适的选择。
3. Sentinel 将新的主节点信息广播给所有从节点和客户端，让它们更新配置信息。
4. 在新的主节点上执行故障转移之前，Sentinel 会先将主节点上的数据同步到新的主节点上，确保数据的一致性和可用性。
5. Sentinel 执行故障转移，将新的主节点切换为主服务，同时将旧的主节点切换为从服务，从而完成 Redis 高可用性的自动切换。

#### 部署多个 sentinel 节点（哨兵集群）？

1. 提高系统可用性：多个 Sentinel 节点可以相互监控，如果某个 Sentinel 节点出现故障或者网络问题，其他 Sentinel 节点可以接替它的监控任务，从而确保整个 Redis 集群的高可用性。
2. 避免单点故障：如果只部署一个 Sentinel 节点，一旦该节点出现故障，整个 Redis 集群的高可用性就会受到影响。因此，部署多个 Sentinel 节点可以避免单点故障的风险。
3. 提高故障转移效率：如果只有一个 Sentinel 节点，它需要承担全部的故障转移任务，可能会导致响应时间较慢或者无法处理大量的请求。而部署多个 Sentinel 节点可以将故障转移任务分散到多个节点上，提高故障转移效率和并发处理能力。
4. 提高监控和管理效率：多个 Sentinel 节点可以提供更全面和准确的监控和管理信息，从而更好地了解 Redis 集群的状态和性能。同时，可以通过 Sentinel 集群管理工具来统一管理多个 Sentinel 节点，降低管理成本。

#### Sentinel 选举机制

1. Sentinel 进程会通过心跳检测来监控 Redis 实例的状态，如果 Sentinel 进程检测到 Redis 主节点下线，它就会发起一次新的主节点选举。
2. Sentinel 进程中的 leader会向其他 Sentinel 进程广播新主节点选举请求。
3. 其他 Sentinel 进程会检查自己的 Redis 实例状态，并对 leader 发来的新主节点选举请求进行投票。投票的结果包括赞成、反对和弃权三种。
4. 如果 Sentinel 进程收到的赞成票超过了集群中节点数的一半，那么它就会成为新的主节点的监控者，并将这个信息发送给其他 Sentinel 进程。
5. 其他 Sentinel 进程会接收到新主节点的监控信息，并将自己的状态更新为从节点。

####  Sentinel 集群中选择出 Leader ？

1. Sentinel 进程会通过心跳检测来监控 Redis 实例的状态，如果发现主节点下线，就会发起一次新的主节点选举。
2. Sentinel 进程中的每个节点都会成为候选 Leader，同时会向其他 Sentinel 进程发送自己的 Leader 信息。
3. Sentinel 进程会按照选举规则（比如连接数、优先级等）进行投票，如果某个 Sentinel 进程获得了超过半数的票数，就会成为新的 Leader。
4. 新的 Leader 会向其他 Sentinel 进程广播自己的选举结果，其他 Sentinel 进程会接收并确认新的 Leader。
5. 其他 Sentinel 进程会成为 Follower，并向新的 Leader 发送心跳检测请求。

#### Sentinel 防止脑裂

脑裂是指一个分布式系统中的节点由于网络故障或其他原因与其他节点失去联系，导致出现两个或多个子集，每个子集认为自己是唯一的主节点并继续对外提供服务，导致数据不一致和服务质量下降的问题。

在 Redis Sentinel 集群中，当主节点出现网络分区时，Sentinel 进程会在 超过了集群中节点数的一半 的Sentinel 进程都无法联系到主节点时才进行故障转移操作，这可以避免脑裂问题的发生。而在进行故障转移操作时，Sentinel 进程会选举出一个新的主节点并将其他 Redis 实例切换到新的主节点上，从而保证了数据的一致性和服务的可用性。

### 20 Redis Cluster 

####  Redis Cluster

Redis Cluster是一个分布式的Redis数据库解决方案，可以提供高可用性和可扩展性。它可以将Redis数据库分布在多个节点上，每个节点都可以处理部分数据，并且可以自动处理节点故障。使用Redis Cluster可以解决单个Redis实例可能遇到的性能瓶颈和容量限制问题。它可以提高可用性，使得Redis集群在某些节点故障的情况下仍能正常工作。此外，Redis Cluster还支持数据分片，可以将大量数据分散到不同的节点上，从而提高吞吐量和性能。

Redis Cluster的**优势**包括：

1. 高可用性：Redis Cluster可以自动处理节点故障，从而提供高可用性。
2. 高扩展性：Redis Cluster可以通过增加节点来扩展容量和性能。
3. 数据分片：Redis Cluster支持数据分片，可以将大量数据分散到不同的节点上，从而提高吞吐量和性能。
4. 写入操作不阻塞：Redis Cluster支持异步复制，可以在主节点接收到写入操作时立即返回，而不必等待从节点确认，从而提高性能。
5. 支持多种数据结构：Redis Cluster支持多种数据结构，包括字符串、哈希表、列表、集合和有序集合，可以满足不同场景的需求。

缺点：

1. 易出现数据丢失问题。Redis Cluster 的主从复制机制虽然可以提高数据可用性，但是在进行故障转移的过程中可能会出现数据丢失的问题。如果在进行故障转移时，正在进行写操作的主节点突然宕机，且还未将数据同步到从节点上，那么这些数据将会永久丢失。
2. 部署和维护成本高。Redis Cluster 的部署和维护需要更多的人力和物力资源，因为需要在多个节点上进行操作，并且需要定期进行故障检测和处理。
3. 不支持事务的跨节点操作。在 Redis Cluster 中，事务只能在单个节点上执行，而不能跨多个节点执行。因此，如果需要进行跨节点的事务操作，就需要在应用程序中进行额外的处理。

#### Redis Cluster 分片

Redis Cluster 是通过分片来实现高可用和横向扩展的。Redis Cluster 的分片机制采用的是哈希槽（hash slot）的方式。

Redis Cluster 将整个键空间划分为 16384 个哈希槽，每个槽都有一个唯一的编号，从 0 到 16383。每个 Redis Cluster 节点都负责管理一部分哈希槽，

当客户端对一个键进行读写操作时，Redis Cluster 首先根据键名计算出该键属于哪个哈希槽，然后将请求路由到负责该槽的节点上。这样，每个节点只需要管理部分哈希槽，而不需要维护整个键空间，从而实现了横向扩展。

如果某个节点宕机或无法响应请求，Redis Cluster 会将该节点管理的哈希槽重新分配到其他节点上，从而保证系统的高可用性。这一过程可以通过节点间的消息交互和重新分配哈希槽来实现。

#### 为什么 Redis Cluster 的哈希槽是 16384 个

65536：发送心跳信息的消息头用bitmap，达65536/8 = 8k，发送的心跳包过于庞大，浪费带宽，且集群master不会很多，一般不会超过1000个。

哈希槽是通过一张bitmap的形式来保存的，在传输过程中，会对bitmap进行压缩。bitmap的填充率越低，**压缩率**越高。其中bitmap 填充率 = slots / N (N表示节点数)。所以，插槽数越低， 填充率会降低，压缩率会提高。

hash分区算法：一致性哈希，就是一个圆那个，CRC16就这个，节点取余

#### 如何确定给定 key 的应该分布到哪个哈希槽中

在 Redis 中，key 的哈希槽计算是通过一个叫做 CRC16 的算法来实现的，具体过程如下：

1. 对 key 进行 CRC16 哈希计算，得到一个 16 位的无符号整数作为哈希值。
2. 取这个哈希值对 16384（哈希槽数量） 取模，得到一个介于 0 到 16383 之间的整数作为 key 对应的哈希槽编号

#### Redis Cluster 支持重新分配哈希槽

1. 手动重分配：管理员可以手动将某些哈希槽从一个节点移动到另一个节点。
2. 自动重分配：Redis Cluster 会自动监测节点的状态，并在需要时进行哈希槽的重新分配。具体来说，当一个节点离线或者新增一个节点时，Redis Cluster 会自动将该节点上的哈希槽重新分配到其他节点上，以保持各个节点上的哈希槽数量相对均衡。在这个过程中，Redis Cluster 会使用一些特殊的算法来优化哈希槽的分配和迁移，以尽可能地减少对 Redis Cluster 的影响。

#### Redis Cluster 扩容缩容期间可以提供服务

当增加或减少 Redis Cluster 的节点时，Redis Cluster 会自动执行哈希槽的重新分配，以保持各个节点上的哈希槽数量相对均衡。

在进行节点的扩容缩容时，可能会导致部分 key 的位置发生变化。因此，在进行节点的扩容缩容时，需要确保 Redis Cluster 的客户端能够正确处理 key 位置变化带来的影响。

在节点的扩容缩容期间，Redis Cluster 会将新节点添加到集群中，并在新节点上复制一定数量的哈希槽。当新节点完全加入 Redis Cluster 并且复制了足够数量的哈希槽后，Redis Cluster 会开始将一部分哈希槽从旧节点转移到新节点。在这个过程中，Redis Cluster 会使用一些特殊的算法来确保各个节点上的哈希槽数量相对均衡，并且尽可能地减少对 Redis Cluster 的影响。

#### Redis Cluster 中的节点是怎么进行通信的

在 Redis Cluster 中，每个节点都通过 TCP/IP 网络协议进行通信。具体来说，每个节点都需要监听一个或多个 TCP 端口，以接受其他节点的请求和发送自己的请求。

当一个节点向 Redis Cluster 发送请求时，它会将请求发送到一个已知的节点，并要求该节点将请求转发到正确的目标节点。如果目标节点是已知的，该节点会将请求转发到目标节点；否则，它会将请求转发给其他已知的节点，直到找到目标节点为止。

当一个节点接收到请求时，它会对请求进行解析，并将请求转发到目标节点。如果目标节点是该节点本身，则该节点会直接处理请求；否则，它会将请求转发到其他节点，直到找到目标节点为止。

在 Redis Cluster 中，节点之间还会使用一些特殊的协议来进行集群管理和数据同步。具体来说，当一个节点加入或离开 Redis Cluster 时，它需要与其他节点交换信息，并与其他节点达成一致。这可以通过使用 Gossip 协议和 PING/PONG 消息来实现。此外，当一个节点接收到写操作时，它需要将写操作复制到一个或多个从节点上，以确保数据的可靠性和高可用性。这可以通过使用主从复制协议和复制 offset 等机制来实现。

