[TOC]



### BIOS 引导 怎么实现？

BIOS作为固件，会把引导盘第一个扇区的代码加载至内存0x7c00处。这段代码会加载loader程序，继续读取磁盘上内核的代码，并放在指定内存处。同时，在初始化过程中，开启保护模式，开启分页机制，初始化GDT表。

### 平坦模型是什么？

平坦模型是现代操作系统采用的管理内存的方式，即段地址都为0，偏移量为实际的访问地址。所有的段统一为4G内存空间。这是因为现代操作系统的寄存器位宽足够大，不再需要像16位时代那样使用段地址+偏移的方式。

### 虚拟内存是什么？

虚拟内存是现代CPU管理内存访问内存的一种方式。在开启分页机制后，CPU访问的内存都是虚拟的，需要经过转换，才能得到真正的物理地址。现代操作系统中，这里通常使用页表来做转换。

虚拟内存的作用：

- 隔离地址空间，每个进程都可以用独立的地址空间，不会冲突
- 借助页表进行访问控制，进程之间不会相互干扰

### 多级页表？

项目采用的是二级页表来管理虚拟内存。具体原理是，将一段虚拟地址，高10位作为页目录表（一级页表）的索引，从这个索引指向的页表项中，取出二级页表的地址，中间十位作为二级页表的索引，取出物理页的地址。然后通过虚拟地址的低12位寻址，定位最终访问的物理地址。

### 进程切换是怎么做的？

每一个进程都有一个进程控制块数据结构，里面的数据成员有进程ID，父进程是谁，当前的时间片，和一个tss结构。这个tss结构储存了进程的上下文信息。

所有的进程都储存在一个进程队列中。每次时钟中断发生时进行轮询。每当当前进程的时间片为0时，将当前进程放入队尾，保存进程上下文（从TR寄存器里可以获得TSS选择子，再去从GDT表里得到TSS的地址），然后读取队头进程，读取它的上下文。

### 互斥锁和信号量？

互斥锁是一个数据结构，里面有两个主要变量，一个是持有锁的进程，一个是阻塞队列。

进程给代码段上锁时，会修改锁的进程变量，指向自己。当另外一个进程要访问这段代码时，会判断锁是否被占用，如果被占用，则将自己加入锁的阻塞队列里。然后放弃当前的CPU时间片，进行进程调度。

当锁的持有者解锁时，会唤醒阻塞队列里面的一个进程，即将阻塞队列里的进程放入就绪队列里。

信号量是一个数据结构，里面的主要变量是计数变量和阻塞队列。提供了两个函数，notify和wait。notify使得计数量+1，wait使得计数量-1。

当一个进程需要执行信号量控制的代码段时，需要调用wait。如果调用wait后计数小于0，则将自己放入阻塞队列中。直到有另一个进程，它使用了notify，会检测阻塞队列中是否有进程在等待。如果有，则将进程放入就绪队列中。如果没有，则将计数+1。

### 内核态和用户态的特权级切换如何实现？

**用户态切换到内核态：中断、系统调用**

特权级主要涉及三种标志位：

- CPU中，CS寄存器的CPL字段，表示当前运行的特权级
- GDT表中的段描述符的DPL字段，表示访问该GDT表所需的特权级
- 段选择子的RPL字段，表示该段执行时的特权级

**中断：**

- CPU访问IDT表，根据中断向量号找到中断描述符，并进行权限检查，切换权限。当前的权限位CPL是3，需要切换到对应的权限位DPL0。
- 权限对比，将当前的CPL和目标段描述符的DPL进行对比
- 若当前权限（CPL数值为3）低于目标代码段权限（DPL数值为0），说明要进行特权级切换，要使用内核栈，并修改CS寄存器
- x86自动从TR寄存器中取出TSS结构，读取esp0，在内核栈中保存ss、esp3，保存eflags，cs，eip
- 进入中断处理函数
- 执行iret指令 读取 eflags, cs, eip。读取 cs 时如果发现权限位不一致，则继续读取 ss，esp，恢复栈。

**系统调用：**

通过用户态程序接口，调用x86的lcall指令，跳转至调用门，进行特权级转换，从高到低。切换栈时，会把用户栈上压入的参数复制进内核栈（根据调用门里的参数数量决定，并且与中断不同的是，不会自动压入EFLAGS寄存器）。



**内核态到用户态：**

执行iret指令，在执行过程中会读取栈中的eflags，cs，ip。如果发现cs中CPL的值和当前的CPL不一致，则说明特权级需要切换，也意味着需要切换栈，继续读取ss，esp即可。



### sleep

sleep把当前进程设置为阻塞态，然后设置它的睡眠时间，放入睡眠队列里，然后调度下一个进程。每次触发时间中断时，会在睡眠队列中让进程的睡眠时间减一。当检测到某个进程睡眠时间为0时，将其唤醒，放到就绪队列中。

### fork

- 首先遍历任务结构体数组，寻找空闲的任务结构体，创建这个子进程。
- 将子进程的TSS：上下文寄存器设置的和父进程的上下文寄存器一致。
- 复制父进程的页表，让子进程建立一份相同的页表，并存入CR3寄存器中。
- 将子进程设置为就绪，加入准备队列。

### exec

exec，因为目前还没有做文件系统，所以目前只做好了这个接口，暂时可以读取内存中的程序。目前实现的效果是，可以加载内存中的elf文件。

- 创建一个新的页表空间，把elf文件装载进页表空间中。
- 分配新的用户栈空间，把栈设置在统一的位置（0xE0000000），并且把exec的参数拷贝到栈指针的位置。
  - **这里要特别注意，由于内存拷贝涉及到两个不同进程空间，传进来的参数可能会跨页表，因此需要额外处理，很复杂**
- 然后把内核栈里的进程上下文寄存器eax, ebx等清零，并设置esp指向新的栈顶，设置CR3指向新的页表。
- 销毁原页表地址空间的内存。
- 返回。此时调用ret返回后，就是新的进程环境了。

用户程序编译时，我设定了会和一个lib库、一个入口函数一起编译。lib库的作用就是提供系统调用的基本接口函数，入口函数的作用就是执行main（给main传入argc，argv），并接收main的返回值，调用exit退出进程。

> 在Cmake里设置了应用程序代码在编译时会和预先写好的一个lib库放在一起，lib库的代码是这段程序运行的首地址，这段代码调用main函数来执行相应的功能
>
> 操作系统在创建进程时，会将一段前置代码放入main前，这段代码需要初始化运行环境，初始化全局变量、堆、寄存器等，并将main的参数放入用户栈里。然后才会调用main函数，执行程序主体部分。执行完毕后，代码接收main的返回值，进行清理工作，全局变量析构，销毁堆，调用exit结束进程。

